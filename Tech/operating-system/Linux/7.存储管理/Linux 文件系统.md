---
title: Linux 文件系统
description: Linux 文件系统管理
keywords:
  - Linux
  - 分区
  - 磁盘
  - 文件系统
tags:
  - Linux/进阶
  - 技术/操作系统
author: 7Wate
date: 2023-04-10
---

## 概念

文件系统是一种用于存储和组织计算机数据的机制，它**使用文件和树形目录的抽象逻辑概念来代替硬盘和光盘等物理设备使用数据块的概念**。文件系统的设计使得对数据的访问和查找变得容易，用户不必关心数据实际保存在硬盘或光盘的哪个地址，只需要记住文件所属的目录和文件名。文件系统自动完成硬盘上的存储空间管理（分配和释放），用户只需要记住数据被写入到哪个文件中。

常见的文件系统列表如下：

- 文件配置表（File Allocation Table，FAT）系列：FAT12、FAT16、FAT32、exFAT
- 新技术文件系统（New Technology File System，NTFS）
- 分层文件系统（Hierarchical File System，HFS）和 HFS Plus
- 延伸文件系统（Extended File System，ext）系列：ext1、ext2、ext3、ext4
- 旧式数据系统（Old Data System，ODS）
- Btrfs（B-tree 文件系统）
- XFS（SGI 的高性能日志文件系统）
- UFS（Unix 文件系统）
- ZFS（Zettabyte 文件系统）

在文件系统中，**文件名**是用于定位存储位置。大多数的文件系统对文件名的长度有限制。文件名可以是大小写不敏感的，也可以是大小写敏感的。现今的文件系统允许文件名包含非常多的 Unicode 字符集的字符，但某些特殊字符在文件名中受限。方便起见，一般不建议在文件名中包含特殊字符。

文件系统还维护**元数据（Metadata）**，包括文件长度、最后修改时间、文件设备类型、文件所有者和访问权限等信息。有些文件系统还保存文件的创建时间、最后访问时间及属性修改时间。元数据还可以包括文件设备类型、字符集、套接口、子目录等信息。

文件系统可以通过**访问控制列表**或 capabilities 实现安全访问，但访问控制列表难以保证安全，因此研发中的文件系统倾向于使用 capabilities。然而目前多数商业性的文件系统仍然使用访问控制列表。

文件系统可以使用硬盘、光盘等物理设备存储数据，也可以通过网络协议提供数据，甚至可能根本没有对应的文件。**严格来说，文件系统是一种实现数据的存储、分级组织、访问和获取等操作的抽象数据类型。**

## Linux 文件系统

在 Linux 系统中支持多种文件系统，如：Ext2、Ext3、Ext4、XFS、Btrfs、NTFS、FAT32、ISO 9660、NFS 等。

| 系统     | 全拼                                     | 功能                                                         | 优点                                                         | 用途                                                      |
| -------- | ---------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | --------------------------------------------------------- |
| Ext2     | Second Extended File System              | 提供基本的文件存储功能                                       | 简单，速度较快，可靠性高                                     | 适用于小型存储设备，如闪存卡                              |
| Ext3     | Third Extended File System               | 在 Ext2 基础上增加了日志功能                                   | 文件系统可靠性更高，具有较好的容错能力                       | 适用于大多数 Linux 发行版，以及需要可靠数据存储的服务器环境 |
| Ext4     | Fourth Extended File System              | 在 Ext3 基础上增加了更多的特性，如更大的文件系统和更高的性能   | 支持大容量文件和高性能文件系统访问                           | 适用于大型服务器和高性能计算机                            |
| XFS      | XFS File System                          | 高性能文件系统，支持大容量文件和高吞吐量应用                 | 速度快，可靠性高，适合高性能计算和大型存储设备               | 适用于需要大容量和高性能访问的服务器环境                  |
| Btrfs    | B-tree File System                       | 先进的文件系统，支持快照、数据压缩和多个设备的联合文件系统等功能 | 可靠性高，能够在多个设备之间提供容错性                       | 适用于需要高效数据管理和可靠存储的服务器和桌面环境        |
| NTFS     | New Technology File System               | Windows 操作系统上的文件系统，支持文件和目录的权限控制和加密等功能 | 可以处理很大的文件系统，能够在 Windows 和 Linux 之间进行数据传输 | 适用于需要与 Windows 系统交互的 Linux 系统                    |
| FAT32    | File Allocation Table 32-bit             | 一种老旧的文件系统，支持大容量的存储设备                     | 可以在不同的操作系统之间进行数据传输，通常用于移动设备和便携式存储介质上 | 适用于小型存储设备，如 USB 闪存盘和 SD 卡                     |
| ISO 9660 | International Standard Organization 9660 | 用于光盘文件系统                                             | 支持只读访问，可以在不同的操作系统之间进行数据传输           | 适用于在 CD 和 DVD 上发布数据的场景                           |
| NFS      | Network File System                      | 一种网络文件系统，可以让不同的机器上的用户共享文件系统       | 能够在不同的计算机之间共享文件和目录，提供高度的数据访问性能 | 适用于需要在多个计算机之间共享文件的网络环                |

### FHS 层次结构

![Linux 文件层次结构图](https://static.7wate.com/img/2023/04/13/a44be4559ea26.png)

> 来源：[Linux 文件系统结构 - Strong在线文档库](https://www.hanzz.red/archives/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84)；仅学术引用，著作权归作者所有。

在 Linux 系统中，文件系统采用了一种层次结构来组织文件和目录，这种层次结构称为**文件系统层次结构**（Filesystem Hierarchy Standard，FHS）。FHS 是一种标准化的文件系统层次结构，规定了在不同的 Linux 系统中应该如何组织文件和目录，以保证文件系统的一致性和兼容性。

| 目录名 | 全拼                  | 功能                         | 用途                                                         |
| ------ | --------------------- | ---------------------------- | ------------------------------------------------------------ |
| /      | Root                  | 根目录                       | 包含所有其他目录和文件的根目录                               |
| /bin   | Binary                | 存放系统二进制可执行文件     | 包含最基本的系统命令                                         |
| /boot  | Boot                  | 存放启动加载程序和内核       | 包含启动 Linux 系统所必需的文件                                |
| /dev   | Device                | 存放设备文件                 | 包含 Linux 系统中所有的设备文件，如硬盘、键盘、鼠标等          |
| /etc   | Etcetera              | 存放系统配置文件             | 包含 Linux 系统中所有的系统配置文件，如网络配置文件、用户账号配置文件等 |
| /home  | Home                  | 存放用户家目录               | 包含所有用户的家目录                                         |
| /lib   | Library               | 存放系统共享库文件           | 包含系统运行时所需要的一些库函数                             |
| /media | Media                 | 存放可移动介质挂载点         | 包含可移动介质的挂载点，如 U 盘、光盘等                        |
| /mnt   | Mount                 | 存放挂载点                   | 包含文件系统挂载点，用于临时挂载其他文件系统                 |
| /opt   | Optional              | 存放第三方应用程序           | 包含安装在系统中的第三方应用程序                             |
| /proc  | Process               | 存放进程相关信息             | 包含 Linux 系统中所有进程的相关信息                            |
| /root  | Root                  | root 用户家目录               | 仅限 root 用户访问的家目录                                     |
| /run   | Run                   | 存放运行时信息               | 包含运行时所需要的各种信息，如进程号等                       |
| /sbin  | System Binary         | 存放系统管理二进制可执行文件 | 包含系统管理员使用的基本命令和系统管理工具                   |
| /srv   | Service               | 存放服务相关数据             | 包含服务相关的数据，如 Web 服务的网站文件                      |
| /sys   | System                | 存放系统设备文件             | 包含系统中所有设备的相关信息                                 |
| /tmp   | Temporary             | 存放临时文件                 | 包含系统中各种临时文件                                       |
| /usr   | Unix Shared Resources | 存放 Unix 共享资源             | 包含系统中大多数应用程序、库文件和文档等                     |
| /var   | Variable              | 存放经常变化的文件           | 包含系统中经常变化的文件，如日志文件、数据库文件等           |

### Inode 文件元数据

**在 Linux 系统中，每个文件都有其对应的元信息，也称为元数据 (metadata)。**元数据包含了文件的基本属性，如文件的创建时间、访问时间、修改时间，文件大小，文件所有者和所属组，文件的权限等等。

以下是一些常见的文件元数据：

- 文件名：文件的名字，用于标识文件。
- 文件类型：表示文件的类型，如普通文件、目录、链接文件、字符设备、块设备等等。
- 文件大小：表示文件的大小，以字节为单位。
- 时间戳：记录了文件的创建时间、访问时间、修改时间等信息。
- 文件权限：文件所有者、所属组、其他用户对文件的读、写、执行权限。
- 文件所有者和所属组：表示文件的所有者和所属组。
- 文件状态：如 inode 号码、硬链接数等。

在 Unix 和类 Unix 操作系统中 文件系统中，每个文件或目录都有一个 inode 号码，它是唯一的，由文件系统分配，文件名只是 inode 的别名而已。当我们打开一个文件时，实际上是根据该文件名找到对应的 inode，然后通过 inode 读取文件的数据。

index node (inode) 是 Unix 和类 Unix 操作系统中的一个重要概念，它是文件系统中用来存储文件或目录的元数据信息的一种数据结构，每个文件或目录都对应一个唯一的 inode。下面是一个示例 inode 表格：

| 文件类型 | inode 号 | 大小 | 拥有者 | 权限 | 访问时间 | 修改时间 | 创建时间 |
| -------- | ------- | ---- | ------ | ---- | -------- | -------- | -------- |
| 普通文件 | 12345   | 1KB  | root   | 644  | 2022/3/1 | 2022/3/2 | 2022/3/1 |

### Dev 物理设备文件

**在 Linux 系统中，一切都是文件**，包括硬件设备也不例外。这是因为在 Linux 中，硬件设备被抽象成了一种特殊的文件类型，称为设备文件（Device file）。设备文件用于对硬件设备进行读写操作，类似于普通文件的读写操作。设备文件分为两种类型：

- **块设备文件**：对应的硬件设备是以块为单位进行读写的设备，**例如硬盘、U 盘等；**
- **字符设备文件**：对应的硬件设备是以字符为单位进行读写的设备，**例如键盘、鼠标、打印机等。**

**在 Linux 系统中，每个设备文件都有一个对应的设备文件名，该文件名通常位于 /dev 目录下，不同的硬件设备会有不同的设备文件名。**通过访问设备文件，用户可以对硬件设备进行操作。例如，如果想要读取硬盘的数据，用户可以通过访问对应的设备文件（如 /dev/sda）来读取数据，而不需要关心具体的物理硬盘是什么型号、连接方式等等。这种抽象的方式让用户更方便地使用硬件设备，并且使得操作系统能够更好地管理硬件设备。

| 硬件设备                   | 命名规则             |
| -------------------------- | -------------------- |
| IDE 接口硬盘               | /dev/hd[a-d]         |
| SCSI、SATA、U 盘            | /dev/sd[a-z]         |
| KVM/QEMU 虚拟设备          | /dev/vd[a-z]         |
| 软盘                       | /dev/fd[0-1]         |
| 打印机                     | /dev/lp[0-15]        |
| CD/DVD 光盘驱动器          | /dev/cdrom           |
| 鼠标设备                   | /dev/mouse           |
| SCSI 接口磁带机或 IDE 接口 | /dev/st0 或 /dev/ht0 |

### 新磁盘挂载

![磁盘挂载流程](https://static.7wate.com/img/2023/04/13/ad3f9a8dfa3f1.png)

1. 插入新硬盘

将新硬盘插入计算机的硬盘插槽中，并连接好数据线和电源线。

1. 查看新硬盘设备信息

确认新硬盘的设备名称：可以使用 `fdisk -l` 命令或者 `lsblk` 命令来列出系统中的所有硬盘设备，找到新硬盘的设备名称。

```shell
$ lsblk
NAME          MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
nvme0n1       259:0    0   64G  0 disk
├─nvme0n1p1   259:1    0    1G  0 part /boot
└─nvme0n1p2   259:2    0   63G  0 part
  ├─rhel-root 253:0    0 39.7G  0 lvm  /
  ├─rhel-swap 253:1    0  3.9G  0 lvm  [SWAP]
  └─rhel-home 253:2    0 19.4G  0 lvm  /home
nvme0n2       259:3    0    8G  0 disk 👈
$ fdisk -l /dev/nvme0n2
Disk /dev/nvme0n2：8 GiB，8589934592 字节，16777216 个扇区
磁盘型号：VMware Virtual NVMe Disk
单元：扇区 / 1 * 512 = 512 字节
扇区大小(逻辑/物理)：512 字节 / 512 字节
I/O 大小(最小/最佳)：512 字节 / 512 字节
```

3.创建硬盘分区

如果新硬盘未被分区，则需要先创建分区。可以使用 `fdisk` 命令来创建分区，然后按照提示创建分区。

```shell
$ fdisk /dev/nvme0n2

欢迎使用 fdisk (util-linux 2.37.4)。
更改将停留在内存中，直到您决定将更改写入磁盘。
使用写入命令前请三思。

设备不包含可识别的分区表。
创建了一个磁盘标识符为 0x70f8d313 的新 DOS 磁盘标签。

命令(输入 m 获取帮助)：n 👈
分区类型
   p   主分区 (0 primary, 0 extended, 4 free)
   e   扩展分区 (逻辑分区容器)
选择 (默认 p)：p 👈
分区号 (1-4, 默认  1): 1 👈
第一个扇区 (2048-16777215, 默认 2048):2048 👈
最后一个扇区，+/-sectors 或 +size{K,M,G,T,P} (2048-16777215, 默认 16777215): +1g 👈

创建了一个新分区 1，类型为“Linux”，大小为 1 GiB。

命令(输入 m 获取帮助)：w 👈
分区表已调整。
将调用 ioctl() 来重新读分区表。
正在同步磁盘。
```

1. 格式化新分区文件系统

**分区创建完成后，需要将分区格式化为文件系统才能挂载。**可以使用 `mkfs` 命令来格式化分区，比如可以使用 `mkfs.ext4 /dev/nvme0n2p1` 命令将 `/dev/nvme0n2p1` 分区格式化为 ext4 文件系统。

```shell
$ lsblk
NAME          MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
nvme0n1       259:0    0   64G  0 disk
├─nvme0n1p1   259:1    0    1G  0 part /boot
└─nvme0n1p2   259:2    0   63G  0 part
  ├─rhel-root 253:0    0 39.7G  0 lvm  /
  ├─rhel-swap 253:1    0  3.9G  0 lvm  [SWAP]
  └─rhel-home 253:2    0 19.4G  0 lvm  /home
nvme0n2       259:3    0    8G  0 disk
└─nvme0n2p1   259:5    0    1G  0 part 👈
$ mkfs.ext4 /dev/nvme0n2p1
mke2fs 1.46.5 (30-Dec-2021)
创建含有 262144 个块（每块 4k）和 65536 个inode的文件系统
文件系统UUID：28337fe9-2ec1-4d39-9001-27595dd569bf
超级块的备份存储于下列块：
        32768, 98304, 163840, 229376

正在分配组表： 完成
正在写入inode表： 完成
创建日志（8192 个块）完成
写入超级块和文件系统账户统计信息： 已完成
```

1. 创建硬盘新分区目录挂载点

在 Linux 中，需要先创建一个目录，作为挂载点，使用 `mount` 命令将分区挂载到该目录下。

```shell
$ mkdir /mnt/newdisk-1gb
$ mount /dev/nvme0n2p1 /mnt/newdisk-1gb/
$ df -h
文件系统               容量  已用  可用 已用% 挂载点
devtmpfs               4.0M     0  4.0M    0% /dev
tmpfs                  1.8G     0  1.8G    0% /dev/shm
tmpfs                  726M  9.1M  717M    2% /run
/dev/mapper/rhel-root   40G  2.2G   38G    6% /
/dev/mapper/rhel-home   20G  171M   20G    1% /home
/dev/nvme0n1p1        1014M  244M  771M   24% /boot
tmpfs                  363M     0  363M    0% /run/user/0
/dev/nvme0n2p1         974M   24K  907M    1% /mnt/newdisk-1gb 👈
```

1. 配置硬盘新分区开机自动挂载目录

```shell
$ df -h
文件系统               容量  已用  可用 已用% 挂载点
devtmpfs               4.0M     0  4.0M    0% /dev
tmpfs                  1.8G     0  1.8G    0% /dev/shm
tmpfs                  726M  9.1M  717M    2% /run
/dev/mapper/rhel-root   40G  2.2G   38G    6% /
/dev/mapper/rhel-home   20G  171M   20G    1% /home
/dev/nvme0n1p1        1014M  244M  771M   24% /boot
tmpfs                  363M     0  363M    0% /run/user/0
/dev/nvme0n2p1         974M   24K  907M    1% /mnt/newdisk-1gb
$ blkid | grep 0n2
/dev/nvme0n2p1: UUID="28337fe9-2ec1-4d39-9001-27595dd569bf" TYPE="ext4" PARTUUID="70f8d313-01"
$ echo "UUID=28337fe9-2ec1-4d39-9001-27595dd569bf /mnt/newdisk-1gb ext4 defaults 0 0" >> /etc/fstab
$ tail -n 1 /etc/fstab
UUID=28337fe9-2ec1-4d39-9001-27595dd569bf /mnt/newdisk-1gb ext4 defaults 0 0
$ mount -a
$ reboot
======================== 重启后 ========================
$ df -h
文件系统               容量  已用  可用 已用% 挂载点
devtmpfs               4.0M     0  4.0M    0% /dev
tmpfs                  1.8G     0  1.8G    0% /dev/shm
tmpfs                  726M  9.1M  717M    2% /run
/dev/mapper/rhel-root   40G  2.2G   38G    6% /
/dev/mapper/rhel-home   20G  171M   20G    1% /home
/dev/nvme0n2p1         974M   24K  907M    1% /mnt/newdisk-1gb 👈
/dev/nvme0n1p1        1014M  244M  771M   24% /boot
tmpfs                  363M     0  363M    0% /run/user/0
```

### 日常巡检

![日常巡检流程](https://static.7wate.com/img/2023/04/13/8e3674e1b65a9.png)

#### 查询磁盘空间使用情况

使用 `df` 命令来查询文件系统的空间使用情况。

```shell
$ df -h
文件系统               容量  已用  可用 已用% 挂载点
devtmpfs               4.0M     0  4.0M    0% /dev
tmpfs                  1.8G     0  1.8G    0% /dev/shm
tmpfs                  726M  9.1M  717M    2% /run
/dev/mapper/rhel-root   40G  2.3G   38G    6% /
/dev/mapper/rhel-home   20G  171M   20G    1% /home
/dev/nvme0n2p1         974M   24K  907M    1% /mnt/newdisk-1gb
/dev/nvme0n1p1        1014M  244M  771M   24% /boot
tmpfs                  363M     0  363M    0% /run/user/0
```

#### 查询目录空间使用情况

使用 `du` 命令来查询指定目录的空间使用情况。

```shell
$ du -h /var | head -n 10
488K    /var/lib/dnf
54M     /var/lib/rpm
0       /var/lib/games
0       /var/lib/misc
0       /var/lib/rpm-state/kernel
0       /var/lib/rpm-state
48K     /var/lib/alternatives
0       /var/lib/selinux/tmp
36K     /var/lib/selinux/targeted/active/modules/100/abrt
20K     /var/lib/selinux/targeted/active/modules/100/accountsd
```

#### 磁盘性能监测

sysstat（System Statistics）是一个系统性能监控工具，它包含了一系列的工具和报告，可以用来监测系统负载、CPU 使用率、内存使用率、网络活动等系统性能指标。sysstat 提供了一些常用的命令行工具，包括 sar、iostat、mpstat、pidstat 等，这些工具可以周期性地获取系统的性能指标数据，并将数据保存在文件中。用户可以使用这些数据来分析系统的负载情况、瓶颈所在等，进一步优化系统性能。

sysstat 的主要功能包括：

- 提供了 sar 工具，可以对系统进行多方面的监控，如 CPU 使用率、内存使用率、IO 使用率等。
- 提供了 iostat 工具，可以监控磁盘 I/O 活动情况。
- 提供了 mpstat 工具，可以监控 CPU 的性能指标，如使用率、上下文切换、中断数等。
- 提供了 pidstat 工具，可以监控进程的性能指标，如 CPU 使用率、内存使用率、IO 活动情况等。
- 提供了 sadf 工具，可以将 sar 工具的输出转换成其他格式，如 CSV、XML、JSON 等。
- 支持将性能监控数据保存到文件中，并提供了一些工具，如 sadc、sa1、sa2 等，来周期性地收集性能数据。
- 支持使用系统日志守护程序来管理和处理系统日志，如 syslogd、rsyslogd 等。

总之，sysstat 提供了一系列强大的性能监控工具和报告，可以帮助用户深入了解系统的性能状况，并及时识别并解决性能瓶颈，从而提高系统的稳定性和可靠性。

## 权限和安全

Linux 文件系统的权限和安全主要可以分为**四个部分：常用权限控制、特殊权限控制、隐藏权限控制和 SELinux 权限控制。**

### 常用权限

**Linux 系统中有三种基本的权限：读（r，read）、写（w，write）和执行（x，execute）**。也可以使用数字来表示文件或目录的权限。每个权限用一个数字表示，分别为 4、2 和 1，分别代表读、写和执行权限。通过将这些数字相加，可以得到一个三位数的数字，用于表示用户、组和其他用户的权限。这些权限分别适用于文件和目录。权限可以分为三组，分别为：**用户（u，user），组（g，group）和其他（o，others）**。

- 文件权限设置为 -rw-r--r--：`chmod 644 file.txt`、`chmod u=rw,g=r,o=r file.txt`
- 文件所有者设置执行权限：`chmod u+x file.txt`
- 文件所有组去除写入和执行权限：`chmod g-wx file.txt`
- 文件其他用户设置只读权限：`chmod o=r file.txt`

*注意：chmod `+` 表示添加权限，`-` 表示删除权限，`=` 表示设置权限。*

```shell
drwxr-xr-x 1 root root 4096 Dec 10 03:15 boot
 
这是一个目录（d开头），权限为rwxr-xr-x，所有者为root，所属组也为root，大小为4096字节，创建时间为12月10日 03:15。

所有者（root）具有读、写和执行权限（rwx）
所属组（root）和其他用户具有读和执行权限（r-x）
总的来说，这个目录的权限是755（rwxr-xr-x），所有者有最高的权限，可以对目录进行任何操作，而组和其他用户只有读和执行权限。
```

| 权限     | 数字 | 文件权限                         | 目录权限                               |
| -------- | ---- | -------------------------------- | -------------------------------------- |
| 读（r）  | 4    | 允许用户读取文件内容             | 允许用户查看目录内容                   |
| 写（w）  | 2    | 允许用户修改文件内容             | 允许用户在目录中创建、删除和重命名文件 |
| 执行 (x) | 1    | 允许用户执行文件（如程序或脚本） | 允许用户进入目录                       |

### 特殊权限

Linux 系统中，特殊权限是指那些不同于常规文件和目录权限（读、写、执行）的权限。这些特殊权限有助于控制用户或进程在访问或操作文件时所拥有的权限。

- 文件设置粘滞位：`chmod o+t`
- 文件取消粘滞位：`chmod o-t`

| 特殊权限            | 示例        | 描述                                                         |
| ------------------- | ----------- | ------------------------------------------------------------ |
| Setuid (suid)       | `chmod u+s` | 当文件具有 setuid 权限时，任何用户在执行该文件时都将获得文件所有者的权限。 |
| Setgid (sgid)       | `chmod g+s` | 当文件具有 setgid 权限时，用户可以以文件所属组的权限执行文件。对于目录，具有 setgid 权限的目录下创建的文件和子目录自动继承该目录的组。 |
| 粘滞位 (Sticky Bit) | `chmod o+t` | 当为目录设置粘滞位时，只有文件所有者和 root 用户可以删除或重命名该目录中的文件。 |

### 隐藏权限

Linux 系统中，隐藏权限通常指那些不容易被用户发现的权限。这些权限可以通过 `chattr` 命令设置，并使用 `lsattr` 命令查看。隐藏权限有助于保护文件免受意外删除或修改，从而增强 Linux 系统的安全性。

- 文件设置不可修改（i）权限：`chattr +i example.txt`
- 文件取消不可修改（i）权限：`chattr -i example.txt`
- 查看文件的隐藏权限：`lsattr example.txt`

| 隐藏权限           | chattr 参数 | 作用                                                     |
| ------------------ | ----------- | -------------------------------------------------------- |
| Immutable          | i           | 无法修改文件，目录中子文件内容可修改，不能新建或删除文件 |
| Append only        | a           | 仅允许追加内容，无法覆盖/删除内容                        |
| Sync               | S           | 文件内容变更后立即同步到硬盘                             |
| Secure deletion    | s           | 彻底删除，不可恢复（用 0 填充原文件所在硬盘区域）        |
| No update of atime | A           | 不再修改文件或目录的最后访问时间                         |
| No update of btime | b           | 不再修改文件或目录的存取时间                             |
| Error checking     | D           | 检查压缩文件中的错误                                     |
| No dump            | d           | 使用 dump 命令备份时忽略本文件/目录                      |
| Compression        | c           | 默认将文件或目录进行压缩                                 |
| Undeletion         | u           | 删除后保留在硬盘中的数据，方便恢复                       |
| Tail-merging       | t           | 让文件系统支持尾部合并                                   |
| Direct access      | x           | 可以直接访问压缩文件中的内容                             |

## 系统分区

**系统分区（system partition）是指计算机中用于存放操作系统和操作系统所需的系统文件和程序的分区，也称为根分区（root partition）。**在计算机中，系统分区是最基本的分区之一，是计算机系统正常运行的核心部分。

**在 PC 机上，系统分区通常使用 MBR（Master Boot Record）或 GPT（GUID Partition Table）格式的分区表来管理磁盘分区。**MBR 是一种旧的分区表格式，它支持最多 4 个主分区或 3 个主分区和 1 个扩展分区，每个分区表项占用 16 个字节。GPT 是一种新的分区表格式，支持最多 128 个分区，每个分区表项占用 128 个字节，可以支持超过 2TB 的硬盘容量。

在 Linux 系统中，系统分区通常包括 /boot、/、/usr、/var、/tmp、/home 等分区。其中，/boot 分区包含了操作系统的内核和引导程序；/ 分区包含了操作系统及其所有文件和程序；/usr 分区包含了系统的共享程序和文件；/var 分区包含了系统运行时生成的变量数据；/tmp 分区是临时文件存储分区；/home 分区则是存放用户数据和个人文件的分区。

在进行磁盘分区时，应该根据计算机的实际情况来选择合适的分区表格式和分区方案，并为每个分区分配正确的类型和大小。在安装操作系统时，应该按照系统要求来分配磁盘空间和设置系统分区，以确保计算机系统的正常运行和数据安全。

### 分区表

**分区表（Partition Table Type）是计算机中用于管理硬盘分区的数据结构，记录硬盘上分区的信息和布局方式。**操作系统通过读取分区表来获取硬盘分区的信息，并根据这些信息进行分区、格式化、挂载等操作。分区表通常存储在硬盘的特定位置，例如 MBR（Master Boot Record）分区表通常存储在硬盘的第一个扇区，而 GPT（GUID Partition Table）分区表则存储在硬盘的最后一个扇区。

分区表的历史可以追溯到早期的操作系统，例如 MS-DOS 和 Windows 95 等。早期的操作系统并不支持硬盘分区的概念，所有数据都存储在同一个分区中，这带来了数据管理和备份的不便，也限制了硬盘容量的利用。

为了克服这些限制，早期的操作系统开始使用分区表来管理硬盘分区。**最早被广泛使用的分区表格式之一是 MBR 分区表，出现于 1983 年，可以管理最多 4 个主分区或 3 个主分区和 1 个扩展分区。**另一种早期的分区表格式是 APM（Apple Partition Map），由苹果公司开发用于管理 Macintosh 计算机上的硬盘分区。

随着计算机硬件的不断升级，MBR 分区表无法满足大容量硬盘的管理需求。于是，新的分区表格式 GPT（GUID Partition Table）应运而生。GPT 使用全球唯一的 GUID 标识硬盘上的分区信息，支持的最大硬盘容量达 EB（exabyte）级别，最多可以管理 128 个分区。GPT 分区表还支持热插拔、校验和、备份分区表等特性，由于使用了 GUID 标识分区信息，GPT 比 MBR 更加安全可靠。

**MBR 分区方案以其广泛的兼容性和简单易用性著称，几乎所有现有的操作系统和硬件都支持 MBR，且其分区表结构简单，便于操作和维护。**然而，MBR 也存在明显的缺点。首先，它只能支持最大 2TB 的硬盘容量，在现代计算机应用中可能不够用。此外，MBR 最多支持四个主分区或三个主分区加一个扩展分区，这在某些情况下显得不足。最重要的是，MBR 没有备份分区表的机制，一旦损坏，可能导致数据丢失。

尽管 MBR 的兼容性较好，但随着计算机技术的发展，MBR 的局限性逐渐显现。未来，MBR 可能会在特定场景下继续使用，例如在旧式硬件或操作系统上。然而，随着硬盘容量的增长和技术的进步，MBR 正逐渐被 GPT 分区方案所取代。GPT 分区方案具有更大的磁盘容量支持、更多的分区数量和更高的数据安全性，已经成为现代操作系统和硬件的首选分区方案。

#### MBR 分区

**MBR（Master Boot Record）是一种分区表结构，位于硬盘的第一个扇区（通常为磁盘的第一个物理扇区，即 LBA 0）。**MBR 包含了操作系统启动引导代码（Bootloader）和分区表信息。MBR 的主要作用是在计算机启动时加载操作系统。

MBR 分区方案的历史可以追溯到 1983 年，当时 IBM PC/AT 发布。当时的 PC/AT 使用 16 位 Intel 80286 处理器，最大寻址空间为 16 MB。随着硬盘容量的增长，MBR 分区方案逐渐显现出容量限制。因此，GPT（GUID Partition Table）分区方案应运而生，取代了 MBR。

##### 标准 MBR 结构

MBR 分区表结构包括以下部分：

1. Bootloader（446 字节）：存放引导加载程序，负责将操作系统从磁盘加载到内存。
2. 分区表（64 字节）：记录了硬盘上分区的信息，如分区类型、分区大小、分区位置等。MBR 支持最多四个主分区或三个主分区加一个扩展分区。扩展分区可进一步划分为多个逻辑分区。
3. 签名（2 字节）：一个固定的值（0x55AA），表示这是一个有效的 MBR 分区表。

| 字节偏移 (Hex) | 字节偏移 (Oct) | 字节偏移 (Dec) | 长度 (Byte) | 描述                                |
| -------------- | -------------- | -------------- | ----------- | ----------------------------------- |
| 0x000          | 0000           | 0              | 446         | Bootloader（引导加载程序）          |
| 0x1BE          | 0676           | 446            | 16          | 主分区 1（分区表条目 1）              |
| 0x1CE          | 0706           | 462            | 16          | 主分区 2（分区表条目 2）              |
| 0x1DE          | 0736           | 478            | 16          | 主分区 3（分区表条目 3）              |
| 0x1EE          | 0766           | 494            | 16          | 主分区 4（分区表条目 4）              |
| 0x1FE          | 0776           | 510            | 2           | 签名（0x55AA，表示有效的 MBR 分区表） |

##### 分区表条目结构

| 字节偏移 (Hex) | 字节偏移 (Oct) | 字节偏移 (Dec) | 长度 (Byte) | 描述                         |
| -------------- | -------------- | -------------- | ----------- | ---------------------------- |
| 0x00           | 000            | 0              | 1           | 引导标识符（80h 为活动分区）  |
| 0x01           | 001            | 1              | 3           | 起始磁头（柱面、磁头、扇区） |
| 0x04           | 004            | 4              | 1           | 分区类型                     |
| 0x05           | 005            | 5              | 3           | 结束磁头（柱面、磁头、扇区） |
| 0x08           | 010            | 8              | 4           | 起始 LBA 地址                  |
| 0x0C           | 014            | 12             | 4           | 分区扇区数                   |

#### GPT 分区

**GPT（GUID Partition Table）是一种分区表结构，适用于新型磁盘和操作系统。**GPT 是 [UEFI](https://uefi.org/)（统一可扩展固件接口）规范的一部分，用于替代传统的 MBR（Master Boot Record）分区表。

**随着计算机技术的发展以及硬盘容量的增长，MBR 分区方案逐渐暴露出容量和分区数量的限制。**为解决这些问题，Intel 在 1999 年引入了 GPT 分区方案。GPT 随后被纳入 UEFI 规范，成为现代计算机系统的主流分区方案。

**GPT 分区方案具有显著的优势，包括支持超过 2TB 的磁盘容量，解决了 MBR 分区方案的容量限制。**此外，GPT 允许创建多达 128 个分区，比 MBR 的分区数量更为灵活。数据安全性方面，GPT 提供了备份分区表的机制，有助于防止数据丢失。然而，GPT 也存在兼容性问题。虽然大多数现代操作系统和硬件都支持 GPT，但在较旧的系统中可能会遇到兼容性障碍。

**GPT 目前主要适用于大容量硬盘（容量大于 2TB）、需要创建超过 4 个分区的情况**，以及支持 UEFI 的现代操作系统和硬件。随着计算机技术的进步和硬盘容量的增加，GPT 分区方案逐渐成为主流，凭借其在磁盘容量支持、分区数量和数据安全性等方面的优势，已成为现代操作系统和硬件的首选分区方案。随着旧式硬件和操作系统的逐渐淘汰，GPT 的普及程度将进一步提高。

展望未来，GPT 分区方案可能会继续演进，以适应新的技术发展和需求。比如，随着硬盘容量的进一步扩大，GPT 可能需要支持更大的磁盘容量和更多的分区数量。此外，为了提高数据安全性，GPT 可能会引入新的数据保护和恢复机制。同时，随着新型存储技术（如固态硬盘和非易失性内存）的发展，可能会出现新的分区方案，以满足这些存储设备的特性和性能需求。

##### 标准 GPT 结构

GPT 分区表结构包括以下部分：

1. 保护性 MBR（LBA 0）：在 GPT 磁盘的第一个扇区，包含一个伪 MBR，以兼容旧式磁盘管理工具。
2. GPT Header（LBA 1）：包含 GPT 分区表的元数据，如分区表大小、分区表位置等。
3. Partition Entry Array（LBA 2～33）：存储分区条目信息。每个分区条目占用 128 字节，典型的 GPT 分区表支持最多 128 个分区。
4. 备份分区表：GPT 在磁盘的末尾备份了 Header 和 Partition Entry Array，以提高数据安全性。

| 区域                       | 起始 LBA (Hex) | 起始 LBA (Oct) | 起始 LBA (Dec) | 长度（扇区） | 描述                                       |
| -------------------------- | ------------- | ------------- | ------------- | ------------ | ------------------------------------------ |
| 保护性 MBR (Protective MBR) | 0x0           | 00000         | 0             | 1            | 保护性主引导记录，用于兼容旧式磁盘管理工具 |
| GPT Header                 | 0x1           | 00001         | 1             | 1            | 包含 GPT 分区表的元数据                      |
| Partition Entry Array      | 0x2           | 00002         | 2             | 32           | 存储分区条目信息，每个分区条目占用 128 字节  |
| 主数据区 (Primary Data)    | 0x22          | 00042         | 34            | 可变         | 磁盘的主要数据存储区域                     |
| 备份 Partition Entry Array  | -0x21         | -00041        | -33           | 32           | 磁盘末尾的备份分区条目数组                 |
| 备份 GPT Header             | -0x1          | -00001        | -1            | 1            | 磁盘末尾的备份 GPT Header                   |

##### 分区条目结构

| 字节偏移 (Hex) | 字节偏移 (Oct) | 字节偏移 (Dec) | 长度 (Byte) | 描述                       |
| -------------- | -------------- | -------------- | ----------- | -------------------------- |
| 0x00           | 000            | 0              | 16          | 分区类型 GUID               |
| 0x10           | 020            | 16             | 16          | 唯一分区 GUID               |
| 0x20           | 040            | 32             | 8           | 起始 LBA 地址                |
| 0x28           | 050            | 40             | 8           | 结束 LBA 地址                |
| 0x30           | 060            | 48             | 8           | 分区属性（如只读、隐藏等） |
| 0x38           | 070            | 56             | 72          | 分区名称（UTF-16LE 编码）   |

### 分区容量

| 分区       | 建议大小     | 说明                                                         |
| ---------- | ------------ | ------------------------------------------------------------ |
| / (根分区) | > 32GB       | 存放操作系统及程序文件，包括系统配置文件、应用程序及库文件等 |
| swap       | > 2GB        | 虚拟内存，用于内存交换，在物理内存不足时起辅助作用           |
| /home      | 剩余磁盘空间 | 存放用户数据和配置文件，根据个人需求分配磁盘空间             |
| /boot      | < 1GB        | 存放引导程序和内核文件，通常只需较小的磁盘空间               |
| /var       | > 16GB       | 存放系统日志、缓存和其他可变数据                             |
| /tmp       | < 32GB       | 存放临时文件                                                 |

综合考虑以上各分区的建议大小，**总共空间建议至少应 ≥ 128GB，这里的建议数值适用于大多数场景**，但请根据具体需求和磁盘空间进行调整。

### 分区工具

#### Parted

`Parted`（GNU Parted）是一个用于磁盘分区和管理的命令行工具，全称为“GNU Partition Editor”。由 GNU 项目开发的自由软件，`Parted` 主要用于创建、修改和删除磁盘分区，在 Linux 系统中广泛应用。它支持多种文件系统和磁盘标签，包括 ext2/ext3/ext4、FAT16/FAT32、NTFS、HFS+、XFS、JFS 等。

##### 历史背景

`Parted` 项目始于 1999 年，由 Andrew Clausen 和 Lennert Buytenhek 开发。其目标是提供一个类似于商业分区工具如 Partition Magic 的功能，但在许可协议方面更自由，同时支持更多的文件系统。随着时间的推移，`Parted` 不断发展，添加了对更多文件系统和分区表的支持，并在许多 Linux 发行版中成为默认的磁盘分区工具。

##### 功能特性

`Parted` 使用库 `libparted` 进行磁盘分区操作。`libparted` 是一个用 C 语言编写的库，提供底层分区表和文件系统的操作接口。`Parted` 的命令行界面调用 `libparted` 的接口，以实现对磁盘分区的管理。这种设计使得其他项目（如图形界面的 GParted）也能利用 `libparted` 提供的功能。

`Parted` 具备以下优点：

- **开源且免费**：遵循 GNU GPL 许可协议。
- **多文件系统支持**：支持多种文件系统和磁盘标签。
- **大容量硬盘支持**：支持大容量硬盘和 GPT 分区表。
- **动态分区调整**：可以在不损坏数据的情况下调整分区大小。
- **脚本自动化**：命令行界面易于编写脚本进行自动化操作。

然而，`Parted` 也存在一些缺点：

- **命令行复杂性**：对新手来说，命令行界面可能不如图形界面直观。
- **文件系统支持限制**：对某些文件系统的支持可能不如专门针对这些文件系统的工具完善。

##### 使用方法

启动 `Parted` 并指定目标磁盘（例如 `/dev/sda`）：

```shell
sudo parted /dev/sda
```

进入 `Parted` 交互界面后，可以使用以下常用命令：

- `print`：显示当前分区表。
- `mklabel`：创建新的磁盘标签（如 `gpt` 或 `msdos`）。
- `mkpart`：创建新分区。
- `rm`：删除现有分区。
- `resizepart`：调整分区大小。
- `quit`：退出 `Parted`。

##### 常用命令

| 操作                 | 命令示例                                      | 说明                                              |
| -------------------- | --------------------------------------------- | ------------------------------------------------- |
| 查看磁盘信息         | parted /dev/sda print                         | 显示 /dev/sda 的磁盘信息                          |
| 选择磁盘             | parted /dev/sda                               | 操作 /dev/sda 磁盘                                |
| 创建分区表           | parted /dev/sda mklabel gpt                   | 在 /dev/sda 上创建 GPT 分区表                     |
| 创建主分区           | parted /dev/sda mkpart primary ext4 1MiB 2GiB | 创建一个从 1MiB 到 2GiB 的 ext4 主分区            |
| 创建扩展分区         | parted /dev/sda mkpart extended 2GiB 4GiB     | 创建一个从 2GiB 到 4GiB 的扩展分区                |
| 创建逻辑分区         | parted /dev/sda mkpart logical ext4 2GiB 4GiB | 创建一个从 2GiB 到 4GiB 的 ext4 逻辑分区          |
| 删除分区             | parted /dev/sda rm 1                          | 删除编号为 1 的分区                               |
| 改变分区文件系统类型 | parted /dev/sda set 1 ext4 on                 | 将编号为 1 的分区的文件系统类型设置为 ext4        |
| 设置引导标志         | parted /dev/sda set 1 boot on                 | 将编号为 1 的分区设置为引导分区                   |
| 移动分区             | parted /dev/sda move 1 2GiB 4GiB              | 将编号为 1 的分区从当前位置移到 2GiB 到 4GiB 之间 |
| 扩展分区             | parted /dev/sda resizepart 1 4GiB             | 将编号为 1 的分区大小扩展到 4GiB                  |
| 缩小分区             | parted /dev/sda resizepart 1 2GiB             | 将编号为 1 的分区大小缩小到 2GiB                  |
| 激活分区             | parted /dev/sda set 1 lvm on                  | 激活编号为 1 的分区以用于 LVM                     |
| 取消激活分区         | parted /dev/sda set 1 lvm off                 | 取消激活编号为 1 的分区以用于 LVM                 |

Parted 提供了一种免费且开源的磁盘分区管理方案，它解决了在 Linux 系统下对磁盘进行分区操作的需求。此外，它还支持许多文件系统和磁盘标签，从而可以满足不同用户的需求。

Parted 适用于在 Linux 系统下进行磁盘分区管理的场景，包括创建、删除、调整分区大小等操作。**它特别适合那些需要进行批量操作或自动化任务的场景，因为其命令行界面易于编写脚本。**

Parted 将继续保持对新文件系统和磁盘技术的支持，以适应不断发展的硬件和软件环境。此外，开发者可能会继续改进其性能和稳定性，以满足用户在各种场景下的需求。随着技术的发展，Parted 也可能会支持新的存储介质，如固态硬盘、NVMe 等。同时，对于一些现有问题，如对特定文件系统支持的不完善，未来可能会有所改进。另外，随着图形界面工具的普及，Parted 可能会与这些工具更紧密地集成，以提供更友好的用户体验。

#### Gdisk

`gdisk`（GUID Partition Table Disk）是一个用于操作 GPT 分区表的命令行工具。它的功能与传统的 `fdisk` 工具类似，但专门针对 GPT 分区表进行了优化。`gdisk` 是由 Rod Smith 开发的，旨在满足大容量硬盘和 UEFI（统一可扩展固件接口）环境下的分区需求。

##### 历史背景

`gdisk` 的开发始于 2009 年，那时 MBR 分区表已经无法满足对大容量硬盘的需求。随着时间的推移，`gdisk` 不断演进，支持了越来越多的功能，成为了处理 GPT 分区表的重要工具。GPT 分区表相对于 MBR 分区表，具有更大的灵活性和扩展性，能够支持更大容量的硬盘和更多的分区数量。

##### 功能特性

`gdisk` 基于 `libparted` 库，通过调用底层库函数来读取、修改、写入 GPT 分区表信息。这使得 `gdisk` 能够在不同的平台上运行。其主要功能包括：

- **查看分区表**：列出磁盘上的所有 GPT 分区及其详细信息。
- **创建新分区**：在未使用的磁盘空间上创建新的 GPT 分区。
- **删除分区**：移除现有的 GPT 分区，使其空间重新变为未使用状态。
- **修改分区**：调整 GPT 分区的大小或属性。
- **转换分区表**：将 MBR 分区表转换为 GPT 分区表。
- **修复分区表**：检查并修复损坏的 GPT 分区表。

##### 使用方法

启动 `gdisk` 并指定目标磁盘（例如 `/dev/sda`）：

```shell
sudo gdisk /dev/sd
```

进入 `gdisk` 交互界面后，可以使用以下常用命令：

- `p`：显示当前分区表。
- `n`：创建新分区。
- `d`：删除现有分区。
- `t`：更改分区类型。
- `w`：写入分区表并退出。
- `q`：退出而不保存更改。
- `r`：进入恢复和转换菜单，执行高级操作。

##### GPT 与 UEFI

GPT 分区表解决了 MBR 分区表的许多限制，例如最大仅支持 2TB 的磁盘容量和最多 4 个主分区的限制。GPT 分区表可以支持更大的磁盘（最大 18EB）和几乎无限数量的分区。此外，GPT 分区表与 UEFI 引导方式兼容，提供了更强的灵活性和更好的系统引导性能。

#### Fdisk

`fdisk` 是一个用于 Linux 系统的磁盘分区管理工具。它提供创建、删除和修改分区表以及设置分区启动标志等功能。`fdisk` 支持 MBR（主引导记录）分区表，是适用于 BIOS 分区表管理的经典工具。

##### 历史背景

`fdisk` 最早出现在 Unix 系统中，随着时间的推移，它被移植到了 Linux 平台。由于其简单易用和功能强大的特点，`fdisk` 成为 Linux 系统中非常受欢迎的分区管理工具。然而，随着 GPT 分区表的出现和逐渐普及，`fdisk` 的功能局限逐渐显现出来，于是 `gdisk` 等工具应运而生，以支持更加现代的 GPT 分区表格式。

##### 功能特性

`fdisk` 通过读取磁盘的主引导记录（MBR）来获取分区信息。MBR 位于磁盘的第一个扇区，包含了分区表和启动程序。使用 `fdisk` 可以执行以下操作：

- **查看分区表**：列出磁盘上的所有分区及其详细信息。
- **创建新分区**：在未使用的磁盘空间上创建新的分区。
- **删除分区**：移除现有的分区，使其空间重新变为未使用状态。
- **修改分区**：调整分区的大小或属性。
- **设置分区启动标志**：标记某个分区为可引导分区。

##### 使用方法

启动 `fdisk` 并指定目标磁盘（例如 `/dev/sda`）：

```
sudo fdisk /dev/sda
```

进入 `fdisk` 交互界面后，可以使用以下常用命令：

- `p`：显示当前分区表。
- `n`：创建新分区。
- `d`：删除现有分区。
- `t`：更改分区类型。
- `a`：切换启动标志。
- `w`：写入分区表并退出。
- `q`：退出而不保存更改。

##### MBR 与 GPT

`fdisk` 主要用于管理 MBR 分区表。MBR 分区表具有以下限制：

- 支持的最大磁盘容量为 2TB。
- 最多只能有 4 个主分区，或者 3 个主分区和 1 个扩展分区（可以包含多个逻辑分区）。

随着硬盘容量的增加和新技术的发展，GPT（GUID 分区表）逐渐取代了 MBR。GPT 支持更大的磁盘和更多的分区，并与 UEFI 引导方式兼容。对于需要管理 GPT 分区表的系统，可以使用 `gdisk` 或 `parted` 等工具。

## 磁盘管理

### 磁盘格式化

磁盘格式化是将磁盘分区初始化为特定的文件系统，以便操作系统能够读写数据。格式化是磁盘准备使用的关键步骤，涉及创建文件系统、设置必要的结构和数据，以确保存储和检索信息的高效性和安全性。

- **mkfs**：通用的文件系统格式化工具，支持多种文件系统类型。
- **mke2fs**：专门用于创建 ext2、ext3、ext4 文件系统的工具。

以下是一些常用的磁盘格式化命令及其说明：

| 命令                     | 说明                                                         |
| ------------------------ | ------------------------------------------------------------ |
| mkfs -t ext4 /dev/sda1   | 将/dev/sda1 分区格式化为 ext4 文件系统                       |
| mke2fs -j /dev/sda1      | 将/dev/sda1 分区格式化为 ext3 文件系统（带日志功能）         |
| mke2fs -b 4096 /dev/sda1 | 将/dev/sda1 分区格式化为 ext2 文件系统，并设置块大小为 4096 字节 |

### 磁盘检查与修复

磁盘检查与修复主要是检查文件系统的完整性、查找并修复磁盘错误。

常用的磁盘检查与修复工具有：

- 文件系统检查：fsck、e2fsck（针对 ext2、ext3、ext4）
- 坏扇区检测：badblocks
- 数据恢复：testdisk、photorec
- 文件系统修复：xfs_repair（针对 xfs）、btrfs-check（针对 btrfs）

常用命令及选项：

| 命令                           | 说明                                                       |
| ------------------------------ | ---------------------------------------------------------- |
| fsck /dev/sda1                 | 检查并尝试修复/dev/sda1 分区的文件系统                     |
| e2fsck -f /dev/sda1            | 强制检查并尝试修复/dev/sda1 分区的 ext2/ext3/ext4 文件系统 |
| badblocks -v /dev/sda1         | 以详细模式检查/dev/sda1 分区的坏扇区                       |
| testdisk /dev/sda              | 检查并尝试恢复/dev/sda 磁盘上的分区表、引导扇区等          |
| photorec /dev/sda1             | 从/dev/sda1 分区中恢复丢失的文件                           |
| xfs_repair /dev/sda1           | 检查并修复/dev/sda1 分区的 xfs 文件系统                    |
| btrfs-check --repair /dev/sda1 | 检查并修复/dev/sda1 分区的 btrfs 文件系统                  |

### 磁盘清理与优化

磁盘清理与优化主要是清除无用的临时文件、整理碎片、压缩磁盘空间以及加密磁盘等操作，以提高磁盘的使用效率和安全性。

常用的磁盘清理与优化工具有：

- 清理临时文件：tmpwatch、systemd-tmpfiles
- 碎片整理：e2fsck（针对 ext 系列）、xfs_fsr（针对 xfs）
- 磁盘压缩：btrfs filesystem defragment（针对 btrfs）
- 磁盘加密：dm-crypt、LUKS、eCryptfs、VeraCrypt 等

常用命令及选项：

| 命令                                   | 说明                                                   |
| -------------------------------------- | ------------------------------------------------------ |
| tmpwatch --mtime 7 /tmp                | 删除/tmp 目录中超过 7 天未修改的临时文件               |
| systemd-tmpfiles --clean               | 按照/tmpfiles.d/目录中的配置文件，清理过期的临时文件   |
| e2fsck -D /dev/sda1                    | 对/dev/sda1 分区的 ext2/ext3/ext4 文件系统进行碎片整理 |
| xfs_fsr /dev/sda1                      | 对/dev/sda1 分区的 xfs 文件系统进行碎片整理            |
| btrfs filesystem defragment /mnt/btrfs | 对挂载在/mnt/btrfs 的 btrfs 文件系统进行压缩整理       |
| cryptsetup luksFormat /dev/sda1        | 使用 LUKS 对/dev/sda1 分区进行加密                     |
| veracrypt --create /dev/sda1           | 使用 VeraCrypt 对/dev/sda1 分区进行加密                |

### 磁盘监控与诊断

磁盘清理与优化主要是清除无用的临时文件、整理碎片、压缩磁盘空间以及加密磁盘等操作，以提高磁盘的使用效率和安全性。

常用的磁盘清理与优化工具有：

- 清理临时文件：tmpwatch、systemd-tmpfiles
- 碎片整理：e2fsck（针对 ext 系列）、xfs_fsr（针对 xfs）
- 磁盘压缩：btrfs filesystem defragment（针对 btrfs）
- 磁盘加密：dm-crypt、LUKS、eCryptfs、VeraCrypt 等

常用命令及选项：

| 命令                                                         | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| tmpwatch --mtime 7 /tmp                                      | 删除/tmp 目录中超过 7 天未修改的临时文件                     |
| systemd-tmpfiles --clean                                     | 按照/tmpfiles.d/目录中的配置文件，清理过期的临时文件         |
| e2fsck -D /dev/sda1                                          | 对/dev/sda1 分区的 ext2/ext3/ext4 文件系统进行碎片整理       |
| xfs_fsr /dev/sda1                                            | 对/dev/sda1 分区的 xfs 文件系统进行碎片整理                  |
| btrfs filesystem defragment /mnt/btrfs                       | 对挂载在/mnt/btrfs 的 btrfs 文件系统进行压缩整理             |
| cryptsetup luksFormat /dev/sda1                              | 使用 LUKS 对/dev/sda1 分区进行加密                           |
| veracrypt --create /dev/sda1                                 | 使用 VeraCrypt 对/dev/sda1 分区进行加密                      |
| fio --name=test --rw=read --bs=4k --numjobs=4 --size=1G --runtime=60s --ioengine=libaio --iodepth=32 --time_based | 测试磁盘的 I/O 性能，以 4K 块大小、深度为 32 的顺序读取方式运行 60 秒的测试 |
| iozone -a -s 1G                                              | 使用 iozone 工具对 1GB 文件进行自动性能测试                  |
| df -h                                                        | 以人类可读的格式显示磁盘空间使用情况                         |
| du -sh /home                                                 | 显示/home 目录的磁盘空间占用情况                             |
| ncdu /home                                                   | 以图形界面显示/home 目录的磁盘空间占用情况                   |
| iostat -xz 5                                                 | 每隔 5 秒输出一次磁盘 I/O 统计信息                           |
| iotop -o                                                     | 实时显示当前磁盘 I/O 活动的进程，只显示有 I/O 操作的进程     |

## LVM

**逻辑卷管理（Logical Volume Management，LVM）是一种在 Linux 系统中管理硬盘空间的技术。**它允许将多个硬盘分区或物理硬盘组合成一个逻辑卷，从而更加灵活地管理存储空间。LVM 允许管理员在不重启系统的情况下调整磁盘空间分配，提供了一些高级的存储管理功能，如快照、镜像和跨磁盘分区等。LVM 通常被用于服务器环境中，因为它可以有效地处理大容量存储设备。

### 历史背景

LVM 最初是由 Sistina Software 公司于 1998 年开发的，旨在提供一种动态分区管理技术，以替代传统的静态分区方式。在 2001 年，Red Hat 收购了 Sistina Software 公司，将 LVM 整合到 Red Hat Enterprise Linux 中，并在 2002 年的 Linux 内核 2.4.0 版本中首次亮相。此后，LVM 逐渐成为了 Linux 系统中的标准组件之一，并且得到了广泛的应用。

### 实现原理

LVM 的实现原理是将物理存储设备（如磁盘、分区）分为若干个物理卷（PV），并将多个物理卷组成一个卷组（VG）。然后在卷组上创建一个或多个逻辑卷（LV），并将逻辑卷格式化为文件系统。当需要增加存储空间时，可以将一个或多个物理卷添加到卷组中，并将空间分配给逻辑卷。当需要缩小存储空间时，可以将逻辑卷缩小，并将空闲空间返回给卷组。

![LVM 构成](https://static.7wate.com/img/2023/04/21/2d92995f6ad28.png)

LVM 由以下三个主要组件组成：

1. **物理卷（Physical Volume，PV）**：物理卷是指磁盘或分区等物理存储设备。在使用 LVM 之前，需要将物理存储设备划分为物理卷，并且将它们标记为 LVM 可用的卷。
2. **卷组（Volume Group，VG）**：卷组是由一个或多个物理卷组成的逻辑容器。卷组可以包含多个物理卷，这些物理卷可以来自不同的磁盘，也可以是同一磁盘上的不同分区。在 LVM 中，卷组是用来为逻辑卷提供空间的。
3. **逻辑卷（Logical Volume，LV）**：逻辑卷是在卷组上创建的逻辑分区。逻辑卷可以动态地分配和释放存储空间，并且可以根据需要调整大小。逻辑卷可以被格式化为文件系统，并像常规分区一样使用。

### 主要特性

逻辑卷管理器（LVM，Logical Volume Manager）是 Linux 系统中管理磁盘存储的灵活且强大的工具。它允许系统管理员在不重新分区的情况下调整文件系统的大小，从而更高效地利用存储资源。LVM 的主要特性包括：

- **动态卷管理**：提供灵活性，允许在系统运行时动态调整存储配置，无需重新启动系统或中断服务。创建、删除和调整逻辑卷和物理卷的大小都变得更加方便。
- **存储虚拟化**：将物理存储设备抽象成卷组（Volume Group, VG）和逻辑卷（Logical Volume, LV），实现更高层次的存储控制。这种虚拟化使得数据可以在物理设备之间移动，而不影响上层应用。
- **卷组与逻辑卷**：卷组将多个物理卷（Physical Volume, PV）聚合，提供统一的存储资源池。逻辑卷可以根据需要调整大小，甚至在多个物理设备之间扩展或缩小，提供极大的灵活性。
- **条带化与镜像**：支持条带化（striping）和镜像（mirroring）功能。条带化通过将数据分散存储在多个物理卷上，提高磁盘 I/O 性能；镜像则提供数据冗余，增强存储系统的可靠性。
- **快照功能**：允许创建卷的时间点副本，用于数据备份、系统恢复和测试，确保数据的一致性和完整性。
- **RAID 支持**：能够与软件 RAID 结合使用，提供额外的数据保护和性能增强。结合 LVM 和 RAID 技术，可以实现更高的灵活性和可靠性。
- **在线调整**：允许在系统运行过程中进行卷的扩展、缩减和迁移，无需停机。这对于高可用性要求高的企业环境尤为重要。
- **简化管理**：提供一系列命令行工具（如 `lvcreate`、`lvremove`、`lvextend`）和图形化界面工具（如 system-config-lvm），使存储管理任务变得简便，降低了管理复杂度。
- **集成与兼容性**：与各种文件系统（如 ext4、XFS、Btrfs）和 Linux 发行版高度集成，提供广泛的兼容性和无缝协作。

### 常用命令

#### 物理卷 (PV) 

| 命令        | 描述                 | 语法格式                              | 示例命令                                          |
| ----------- | -------------------- | ------------------------------------- | ------------------------------------------------- |
| `pvchange`  | 更改物理卷属性       | `pvchange [选项] 物理卷`              | `pvchange -x n /dev/sda1`                         |
| `pvck`      | 检查物理卷的一致性   | `pvck 物理卷`                         | `pvck /dev/sda1`                                  |
| `pvcreate`  | 创建一个新的物理卷   | `pvcreate 设备`                       | `pvcreate /dev/sda1`                              |
| `pvdisplay` | 显示物理卷的属性     | `pvdisplay [选项] [物理卷]`           | `pvdisplay /dev/sda1`                             |
| `pvmove`    | 移动物理卷上的数据   | `pvmove [选项] 源物理卷 [目标物理卷]` | `pvmove /dev/sda1 /dev/sdb1`                      |
| `pvremove`  | 从卷组中移除物理卷   | `pvremove 物理卷`                     | `pvremove /dev/sda1`                              |
| `pvresize`  | 调整物理卷的大小     | `pvresize [选项] 物理卷`              | `pvresize --setphysicalvolumesize 500G /dev/sda1` |
| `pvs`       | 显示物理卷的概要信息 | `pvs [选项] [物理卷]`                 | `pvs`                                             |
| `pvscan`    | 扫描系统中的物理卷   | `pvscan [选项]`                       | `pvscan`                                          |

#### 卷组 (VG) 

| 命令              | 描述               | 语法格式                            | 示例命令                               |
| ----------------- | ------------------ | ----------------------------------- | -------------------------------------- |
| `vgcfgbackup`     | 备份卷组配置       | `vgcfgbackup [选项] 卷组`           | `vgcfgbackup vg01`                     |
| `vgcfgrestore`    | 恢复卷组配置       | `vgcfgrestore [选项] 卷组`          | `vgcfgrestore vg01`                    |
| `vgchange`        | 更改卷组属性       | `vgchange [选项] 卷组`              | `vgchange -a y vg01`                   |
| `vgck`            | 检查卷组的一致性   | `vgck [选项] 卷组`                  | `vgck vg01`                            |
| `vgcreate`        | 创建一个新的卷组   | `vgcreate 卷组 物理卷...`           | `vgcreate vg01 /dev/sda1`              |
| `vgconvert`       | 转换卷组元数据格式 | `vgconvert [选项] 卷组`             | `vgconvert --metadataformat lvm2 vg01` |
| `vgdisplay`       | 显示卷组的属性     | `vgdisplay [选项] [卷组]`           | `vgdisplay vg01`                       |
| `vgexport`        | 导出卷组           | `vgexport [选项] 卷组`              | `vgexport vg01`                        |
| `vgextend`        | 向卷组中添加物理卷 | `vgextend 卷组 物理卷`              | `vgextend vg01 /dev/sdb1`              |
| `vgimport`        | 导入卷组           | `vgimport [选项] 卷组`              | `vgimport vg01`                        |
| `vgimportclone`   | 导入克隆卷组       | `vgimportclone [选项] 卷组`         | `vgimportclone vg01`                   |
| `vgimportdevices` | 导入设备的卷组     | `vgimportdevices [选项] 卷组`       | `vgimportdevices vg01`                 |
| `vgmerge`         | 合并两个卷组       | `vgmerge 卷组1 卷组2`               | `vgmerge vg01 vg02`                    |
| `vgmknodes`       | 重建设备节点       | `vgmknodes [选项]`                  | `vgmknodes`                            |
| `vgreduce`        | 从卷组中移除物理卷 | `vgreduce 卷组 物理卷`              | `vgreduce vg01 /dev/sda1`              |
| `vgremove`        | 删除卷组           | `vgremove 卷组`                     | `vgremove vg01`                        |
| `vgrename`        | 重命名卷组         | `vgrename 卷组 新名称`              | `vgrename vg01 vg02`                   |
| `vgs`             | 显示卷组的概要信息 | `vgs [选项] [卷组]`                 | `vgs`                                  |
| `vgscan`          | 扫描系统中的卷组   | `vgscan [选项]`                     | `vgscan`                               |
| `vgsplit`         | 分割卷组           | `vgsplit [选项] 卷组1 卷组2 物理卷` | `vgsplit vg01 vg02 /dev/sda1`          |

#### 逻辑卷 (LV) 

| 命令        | 描述                 | 语法格式                    | 示例命令                                |
| ----------- | -------------------- | --------------------------- | --------------------------------------- |
| `lvcreate`  | 创建一个新的逻辑卷   | `lvcreate [选项] 卷组`      | `lvcreate -L 10G -n lv01 vg01`          |
| `lvchange`  | 更改逻辑卷属性       | `lvchange [选项] 逻辑卷`    | `lvchange -ay /dev/vg01/lv01`           |
| `lvconvert` | 转换逻辑卷类型       | `lvconvert [选项] 逻辑卷`   | `lvconvert --type raid1 /dev/vg01/lv01` |
| `lvdisplay` | 显示逻辑卷的属性     | `lvdisplay [选项] [逻辑卷]` | `lvdisplay /dev/vg01/lv01`              |
| `lvextend`  | 扩展逻辑卷的大小     | `lvextend [选项] 逻辑卷`    | `lvextend -L +5G /dev/vg01/lv01`        |
| `lvreduce`  | 缩减逻辑卷的大小     | `lvreduce [选项] 逻辑卷`    | `lvreduce -L 5G /dev/vg01/lv01`         |
| `lvremove`  | 删除逻辑卷           | `lvremove 逻辑卷`           | `lvremove /dev/vg01/lv01`               |
| `lvrename`  | 重命名逻辑卷         | `lvrename 逻辑卷 新名称`    | `lvrename /dev/vg01/lv01 lv02`          |
| `lvresize`  | 调整逻辑卷的大小     | `lvresize [选项] 逻辑卷`    | `lvresize -L 15G /dev/vg01/lv01`        |
| `lvs`       | 显示逻辑卷的概要信息 | `lvs [选项] [逻辑卷]`       | `lvs`                                   |
| `lvscan`    | 扫描系统中的逻辑卷   | `lvscan [选项]`             | `lvscan`                                |

#### 其他命令

| 命令                | 描述                   | 语法格式                   | 示例命令                        |
| ------------------- | ---------------------- | -------------------------- | ------------------------------- |
| `lvm`               | LVM 命令的主入口       | `lvm [命令]`               | `lvm`                           |
| `lvm.conf`          | LVM 配置文件           | `n/a`                      | `n/a`                           |
| `lvmconfig`         | 显示和更新 LVM 配置    | `lvmconfig [选项]`         | `lvmconfig --type full`         |
| `lvmdevices`        | 管理 LVM 设备          | `lvmdevices [选项]`        | `lvmdevices --adddev /dev/sda1` |
| `lvm-fullreport`    | 显示 LVM 完整报告      | `lvm-fullreport [选项]`    | `lvm-fullreport`                |
| `lvm-lvpoll`        | 轮询 LVM 逻辑卷        | `lvm-lvpoll [选项]`        | `lvm-lvpoll`                    |
| `blkdeactivate`     | 停用块设备             | `blkdeactivate [选项]`     | `blkdeactivate all`             |
| `lvmdump`           | 创建 LVM 状态转储文件  | `lvmdump [选项]`           | `lvmdump --dumpconfig`          |
| `dmeventd`          | 设备映射事件守护进程   | `dmeventd [选项]`          | `dmeventd -d`                   |
| `lvmpolld`          | LVM 轮询守护进程       | `lvmpolld [选项]`          | `lvmpolld -d`                   |
| `lvmlockd`          | LVM 锁定守护进程       | `lvmlockd [选项]`          | `lvmlockd -d`                   |
| `lvmlockctl`        | 控制 LVM 锁定          | `lvmlockctl [选项]`        | `lvmlockctl --gl`               |
| `cmirrord`          | 集群镜像守护进程       | `cmirrord [选项]`          | `cmirrord -d`                   |
| `lvmdbusd`          | LVM D-Bus 守护进程     | `lvmdbusd [选项]`          | `lvmdbusd -d`                   |
| `fsadm`             | 文件系统调整           | `fsadm [选项] 操作`        | `fsadm resize /dev/vg01/lv01`   |
| `lvmsystemid`       | 显示 LVM 系统 ID       | `lvmsystemid [选项]`       | `lvmsystemid`                   |
| `lvmreport`         | 生成 LVM 报告          | `lvmreport [选项]`         | `lvmreport --all`               |
| `lvmcache`          | 管理 LVM 缓存          | `lvmcache [选项]`          | `lvmcache --config`             |
| `lvmraid`           | 管理 LVM RAID          | `lvmraid [选项]`           | `lvmraid --status`              |
| `lvmthin`           | 管理 LVM 精简卷        | `lvmthin [选项]`           | `lvmthin --usage`               |
| `lvmvdo`            | 管理 LVM VDO           | `lvmvdo [选项]`            | `lvmvdo --status`               |
| `lvmautoactivation` | 自动激活 LVM 逻辑卷    | `lvmautoactivation [选项]` | `lvmautoactivation --status`    |
| `dmsetup`           | 设备映射器的命令行接口 | `dmsetup [命令]`           | `dmsetup status`                |
| `dmstats`           | 设备映射器统计信息     | `dmstats [命令]`           | `dmstats list`                  |
| `readline`          | 命令行编辑库           | `n/a`                      | `n/a`                           |

### 常用选项

| 选项/全拼                 | 释义                                     |
| ------------------------- | ---------------------------------------- |
| `-v, --verbose`           | 显示详细的信息                           |
| `-f, --force`             | 强制执行操作                             |
| `-L, --size`              | 指定逻辑卷的大小                         |
| `-n, --name`              | 指定逻辑卷的名称                         |
| `-i, --stripes`           | 指定逻辑卷的条带数                       |
| `-r, --resizefs`          | 在逻辑卷大小改变后自动调整文件系统       |
| `-a, --activate`          | 激活或停用卷                             |
| `-y, --yes`               | 自动回答“是”以确认操作                   |
| `-P, --partial`           | 允许部分操作完成                         |
| `--addtag`                | 向卷、卷组或物理卷添加标签               |
| `--deltag`                | 从卷、卷组或物理卷删除标签               |
| `--config`                | 使用特定配置文件                         |
| `--metadatacopies n`      | 设置元数据区域的备份级别为 n             |
| `--setphysicalvolumesize` | 调整物理卷的大小                         |
| `-l, --extents`           | 指定逻辑卷的大小，以PE（物理扩展）的数量 |
| `-s, --snapshot`          | 创建逻辑卷的快照                         |
| `-t, --test`              | 运行测试模式，不实际执行命令             |
| `-v, --verbose`           | 显示详细输出                             |

### LVM 示例

```mermaid
graph LR;
    A[创建物理卷 PV] --> B[创建卷组 VG ];
    B --> C[创建逻辑卷 LV ];
    C --> D[格式化文件系统];
    D --> E[挂载文件系统];
    E --> F[使用文件系统];
    
```

1. 创建物理卷 (PV)

在实际操作中，我们需要首先查看系统中有哪些可用的物理卷，使用命令 `lsblk` 可以列出所有的物理磁盘及其分区信息。然后使用 `pvcreate` 命令将指定的物理卷初始化为 LVM 物理卷，例如：

```shell
$ lsblk
NAME          MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
nvme0n1       259:0    0   64G  0 disk
├─nvme0n1p1   259:1    0    1G  0 part /boot
└─nvme0n1p2   259:2    0   63G  0 part
  ├─rhel-root 253:0    0 39.7G  0 lvm  /
  ├─rhel-swap 253:1    0  3.9G  0 lvm  [SWAP]
  └─rhel-home 253:2    0 19.4G  0 lvm  /home
nvme0n2       259:3    0    8G  0 disk
nvme0n3       259:4    0    8G  0 disk
$ pvcreate /dev/nvme0n2 
  Physical volume "/dev/nvme0n2" successfully created.
$ pvcreate /dev/nvme0n3
  Physical volume "/dev/nvme0n3" successfully created.
```

1. 创建卷组 (VG)

在物理卷初始化之后，我们需要将其添加到一个卷组中。使用 `vgcreate` 命令可以创建一个新的卷组，并将一个或多个物理卷添加到其中，例如：

```shell
$ vgcreate data_nvme_vg /dev/nvme0n2 /dev/nvme0n3
  Volume group "data_nvme_vg" successfully created
$ vgdisplay data_nvme_vg
  --- Volume group ---
  VG Name               data_nvme_vg
  System ID
  Format                lvm2
  Metadata Areas        2
  Metadata Sequence No  1
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                0
  Open LV               0
  Max PV                0
  Cur PV                2
  Act PV                2
  VG Size               15.99 GiB
  PE Size               4.00 MiB
  Total PE              4094
  Alloc PE / Size       0 / 0
  Free  PE / Size       4094 / 15.99 GiB
  VG UUID               MbZpcX-1H5P-RKBU-aEAM-9AE3-ums0-nQ2zVc
```

1. 创建逻辑卷 (LV)

在卷组创建之后，我们可以使用 `lvcreate` 命令创建一个或多个逻辑卷，并指定它们的大小、名称、副本数等信息，例如：

```shell
$ lvcreate -L 8G -n data_nvme_lv1 data_nvme_vg
  Logical volume "data_nvme_lv1" created.
$ lvdisplay /dev/data_nvme_vg/data_nvme_lv1
  --- Logical volume ---
  LV Path                /dev/data_nvme_vg/data_nvme_lv1
  LV Name                data_nvme_lv1
  VG Name                data_nvme_vg
  LV UUID                YFSoPg-xCQu-EFLB-lqUC-o7u5-5bhS-N6LJRT
  LV Write Access        read/write
  LV Creation host, time rhel, 2023-04-24 10:23:20 +0800
  LV Status              available
  # open                 0
  LV Size                8.00 GiB
  Current LE             2048
  Segments               2
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     8192
  Block device           253:3
```

1. 格式化文件系统

在逻辑卷创建之后，我们需要格式化其文件系统以便进行挂载和使用。使用 `mkfs` 命令可以对逻辑卷上的文件系统进行格式化，例如：

```shell
$ mkfs.ext4 /dev/data_nvme_vg/data_nvme_lv1
mke2fs 1.46.5 (30-Dec-2021)
创建含有 2097152 个块（每块 4k）和 524288 个inode的文件系统
文件系统UUID：68dd2677-4f0e-421f-bf14-9216eb34b3e5
超级块的备份存储于下列块：
        32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632

正在分配组表： 完成
正在写入inode表： 完成
创建日志（16384 个块）完成
写入超级块和文件系统账户统计信息： 已完成
```

1. 挂载文件系统

在格式化文件系统之后，我们需要将其挂载到系统中的一个目录中，以便进行使用。使用 `mount` 命令可以将格式化后的文件系统挂载到指定的目录中，例如：

```shell
$ mkdir /mnt/data_nvme_lv1
$ mount /dev/data_nvme_vg/data_nvme_lv1 /mnt/data_nvme_lv1/
```

1. 使用文件系统

最后，我们可以在挂载的文件系统上进行文件的读写和访问等操作，例如：

```shell
$ cd /mnt/data_nvme_lv1/
$ ll
总用量 16
drwx------. 2 root root 16384  4月 24 10:25 lost+found
[root@rhel data_nvme_lv1]# echo "hello world!" >> demo.txt
[root@rhel data_nvme_lv1]# cat demo.txt
hello world!
```

1. 调整逻辑卷容量大小

如果想调整 lv 逻辑卷的容量大小可以使用 `lvextend`、`resize2fs`，例如为 `/dev/data_nvme_vg/data_nvme_lv1` 增加 2GB 容量。

```shell
$ lvextend -L +2G /dev/data_nvme_vg/data_nvme_lv1
  Size of logical volume data_nvme_vg/data_nvme_lv1 changed from 8.00 GiB (2048 extents) to 10.00 GiB (2560 extents).
  Logical volume data_nvme_vg/data_nvme_lv1 successfully resized.
$ resize2fs /dev/data_nvme_vg/data_nvme_lv1
resize2fs 1.46.5 (30-Dec-2021)
/dev/data_nvme_vg/data_nvme_lv1 上的文件系统已被挂载于 /mnt/data_nvme_lv1；需要进行在线调整大小

old_desc_blocks = 1, new_desc_blocks = 2
/dev/data_nvme_vg/data_nvme_lv1 上的文件系统现在为 2621440 个块（每块 4k）。

$ df -h /dev/data_nvme_vg/data_nvme_lv1
文件系统                                容量  已用  可用 已用% 挂载点
/dev/mapper/data_nvme_vg-data_nvme_lv1  9.8G   28K  9.3G    1% /mnt/data_nvme_lv1
```

## 其他文件系统

### 网络文件系统

网络文件系统（如 NFS、Samba）允许不同操作系统的计算机在网络上共享文件和目录。这使得跨平台文件共享变得简单，提高了团队协作效率。NFS 主要用于 UNIX/Linux 系统间的文件共享，而 Samba 则提供了在 Windows 和 UNIX/Linux 系统间共享文件的能力。

### iSCSI

iSCSI（Internet Small Computer System Interface）是一种网络存储技术，允许将存储设备（如磁盘阵列）共享给其他计算机。通过 iSCSI，计算机可以通过网络访问共享的存储设备，就像直接连接到本地硬盘一样。这大大简化了存储管理，并提高了存储资源的利用率。

### RAID 透传

RAID 透传是一种将物理 RAID 卡的功能直接传递给虚拟机的技术。通过 PCIe 直通，虚拟机可以直接访问 RAID 卡，从而获得更好的存储性能和可靠性。这种方法允许虚拟机完全利用 RAID 卡的性能和冗余功能，提高数据保护和虚拟机性能。

### 存储池

存储池是一种将多个物理磁盘组合成一个逻辑存储单元的技术。一些现代文件系统（如 ZFS、Btrfs）支持存储池功能，允许管理员轻松地添加、删除或替换磁盘，以满足存储需求。存储池提供了数据冗余、快照、自动修复等高级功能，确保数据的可靠性和完整性。

### 分布式存储

分布式存储系统（如 Ceph、GlusterFS）是一种将数据分散在多个存储节点上的技术，实现高可用、高扩展性的存储方案。分布式存储系统通常采用数据副本、纠删码等技术保证数据的可靠性，当部分存储节点发生故障时，系统仍然可以继续提供服务。此外，分布式存储系统具有良好的横向扩展性，可以通过添加更多节点来扩展存储容量和性能。

## 备份恢复

备份恢复是计算机系统管理的重要部分，涉及到数据的备份、存储和恢复等操作。通过合理的备份策略和方式，可以确保系统的稳定性和数据的安全。

### 备份策略

备份策略是指备份数据的范围和周期。常见的备份策略：

| 备份策略     | 优点                                                         | 缺点                                                         | 适用场景                                                     |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 完整备份     | 可以完整地备份所有数据，恢复时速度快                         | 备份时间长，备份数据量大，占用存储空间大                     | 数据量较小、备份频率较低、对数据完整性要求较高的场景         |
| 增量备份     | 备份时间短，占用存储空间小，可以快速备份所有修改的数据       | 恢复速度慢，需要还原完整的备份链，备份链中任意一次备份失败，后续备份将无法进行 | 大量数据需要备份，数据变化较频繁的场景                       |
| 差异备份     | 备份数据量小，备份速度快，恢复速度快                         | 恢复速度慢，需要还原完整的备份链，备份链中任意一次备份失败，后续备份将无法进行 | 备份频率较高，数据变化较频繁，但备份数据量不宜过大的场景     |
| 定期备份     | 定期备份可以保证备份数据的实时性和完整性                     | 需要人工干预备份，可能会漏备                                 | 数据量较大、需要保证数据实时性和完整性的场景                 |
| 混合备份策略 | 可以充分利用完整备份、增量备份和差异备份各自的优点，灵活备份 | 实现较为复杂，管理备份链需要一定的技术水平，备份数据量大     | 数据量较大、备份频率较高、需要保证备份数据完整性和实时性的场景 |

**备份策略的选择应该根据实际的业务需求和场景来确定。**例如，对于一个数据量较小、备份频率较低、对数据完整性要求较高的场景，完整备份可能是更好的选择，但如果数据变化较频繁，备份数据量较大，增量备份或差异备份可能是更好的选择。在实际应用中，也可以根据不同的数据类型和备份需求，结合多种备份策略进行混合备份，以达到更好的备份效果。

### 备份方式

备份方式是指备份的数据类型和范围。常见的备份方式：

| 备份类型 | 概念                               | 优点                                           | 缺点                                               | 适用场景                                                   |
| -------- | ---------------------------------- | ---------------------------------------------- | -------------------------------------------------- | ---------------------------------------------------------- |
| 系统备份 | 对整个操作系统进行备份             | 备份恢复速度快，可快速恢复整个系统             | 需要重启系统才能恢复，需要专业技术人员进行操作     | 升级系统、修复系统、系统迁移、系统备份恢复                 |
| 数据备份 | 对重要数据进行备份                 | 备份恢复速度快，只恢复需要的数据，节省存储空间 | 无法恢复系统设置，不适用于系统级别的恢复           | 备份重要数据、恢复文件和数据                               |
| 分区备份 | 对磁盘分区进行备份                 | 可以备份恢复单独的分区                         | 无法恢复其他分区的数据，恢复速度慢                 | 对某个分区进行备份、对分区进行数据恢复                     |
| 磁盘备份 | 对整个硬盘进行备份，包括系统和数据 | 备份恢复速度快，可快速恢复整个系统             | 需要专业技术人员进行操作，恢复速度慢，备份数据量大 | 硬盘更换、系统崩溃、病毒攻击、数据丢失等紧急情况的备份恢复 |

**不同类型的备份应该根据实际的业务需求和场景来选择。**例如，对于需要备份整个系统的情况，系统备份可能是最好的选择；对于只需要备份重要数据的情况，数据备份可能是更好的选择；对于需要备份整个硬盘的情况，磁盘备份可能是最好的选择。在实际应用中，也可以结合多种备份方式进行备份，以达到更好的备份效果。

### 备份工具

备份工具是用于执行备份任务的软件。常见的备份工具有：

- 文件级别备份：rsync、tar、cpio、duplicity 等
- 块级别备份：dd、partclone、Clonezilla 等
- 数据库备份：mysqldump、pg_dump、oracle-exp 等

常用命令及选项：

| 命令                                         | 说明                                                         |
| -------------------------------------------- | ------------------------------------------------------------ |
| rsync -avz /src/ /dst/                       | 使用 rsync 工具将/src/目录下的文件同步到/dst/目录下          |
| tar czf backup.tar.gz /src/                  | 使用 tar 工具将/src/目录下的文件打包成 backup.tar.gz 文件    |
| cpio -o > backup.cpio < filelist.txt         | 使用 cpio 工具将 filelist.txt 中的文件打包成 backup.cpio 文件 |
| duplicity /src/ file:///dst/                 | 使用 duplicity 工具将/src/目录下的文件加密并备份到/dst/目录下 |
| dd if=/dev/sda1 of=backup.img                | 使用 dd 工具备份/dev/sda1 分区到 backup.img 文件             |
| partclone.ext4 -c -s /dev/sda1 -o backup.img | 使用 partclone 工具备份 ext4 格式的/dev/sda1 分区到 backup.img 文件 |
| mysqldump -u user -p dbname > backup.sql     | 使用 mysqldump 工具备份 MySQL 数据库到 backup.sql 文件       |
| pg_dump -U user dbname > backup.sql          | 使用 pg_dump 工具备份 PostgreSQL 数据库到 backup.sql 文件    |

### 恢复操作

恢复操作是指根据备份数据恢复系统或数据的过程。常见的恢复操作有：

- 系统还原：使用系统备份恢复操作系统、配置文件、应用程序等
- 数据恢复：从数据备份中恢复用户数据、数据库等
- 磁盘恢复：使用磁盘备份恢复整个磁盘及其上的所有分区
- 备份恢复策略：根据备份策略选择合适的恢复方法和顺序

常用命令及选项：

| 命令                                         | 说明                                                         |
| -------------------------------------------- | ------------------------------------------------------------ |
| rsync -avz /src/ /dst/                       | 使用 rsync 工具从/src/目录下恢复文件到/dst/目录下            |
| tar xzf backup.tar.gz -C /dst/               | 使用 tar 工具从 backup.tar.gz 文件恢复文件到/dst/目录下      |
| cpio -i < backup.cpio                        | 使用 cpio 工具从 backup.cpio 文件恢复文件                    |
| duplicity restore file:///src/ /dst/         | 使用 duplicity 工具从/src/目录下的加密备份恢复文件到/dst/目录下 |
| dd if=backup.img of=/dev/sda1                | 使用 dd 工具从 backup.img 文件恢复/dev/sda1 分区             |
| partclone.ext4 -r -s backup.img -o /dev/sda1 | 使用 partclone 工具从 backup.img 文件恢复 ext4 格式的/dev/sda1 分区 |
| mysql -u user -p dbname < backup.sql         | 使用 mysql 命令恢复 MySQL 数据库从 backup.sql 文件           |
| psql -U user dbname < backup.sql             | 使用 psql 命令恢复 PostgreSQL 数据库从 backup.sql 文件       |
