---
title: Linux 文件系统
description: Linux 文件系统管理
keywords:
- Linux 
- 分区
- 磁盘
- 文件系统
tags:
- Linux
sidebar_position: 1
author: 7Wate
date: 2023-04-10
---

## 概念

文件系统是一种用于存储和组织计算机数据的机制，它**使用文件和树形目录的抽象逻辑概念来代替硬盘和光盘等物理设备使用数据块的概念**。文件系统的设计使得对数据的访问和查找变得容易，用户不必关心数据实际保存在硬盘或光盘的哪个地址，只需要记住文件所属的目录和文件名。文件系统自动完成硬盘上的存储空间管理（分配和释放），用户只需要记住数据被写入到哪个文件中。

常见的文件系统列表如下：

- 文件配置表（File Allocation Table，FAT）系列：FAT12、FAT16、FAT32、exFAT
- 新技术文件系统（New Technology File System，NTFS）
- 分层文件系统（Hierarchical File System，HFS）和HFS Plus
- 延伸文件系统（Extended File System，ext）系列：ext1、ext2、ext3、ext4
- 旧式数据系统（Old Data System，ODS）
- Btrfs（B-tree文件系统）
- XFS（SGI的高性能日志文件系统）
- UFS（Unix文件系统）
- ZFS（Zettabyte文件系统）

在文件系统中，**文件名**是用于定位存储位置。大多数的文件系统对文件名的长度有限制。文件名可以是大小写不敏感的，也可以是大小写敏感的。现今的文件系统允许文件名包含非常多的 Unicode 字符集的字符，但某些特殊字符在文件名中受限。方便起见，一般不建议在文件名中包含特殊字符。

文件系统还维护**元数据（Metadata）**，包括文件长度、最后修改时间、文件设备类型、文件所有者和访问权限等信息。有些文件系统还保存文件的创建时间、最后访问时间及属性修改时间。元数据还可以包括文件设备类型、字符集、套接口、子目录等信息。

文件系统可以通过**访问控制列表**或 capabilities 实现安全访问，但访问控制列表难以保证安全，因此研发中的文件系统倾向于使用 capabilities。然而目前多数商业性的文件系统仍然使用访问控制列表。

文件系统可以使用硬盘、光盘等物理设备存储数据，也可以通过网络协议提供数据，甚至可能根本没有对应的文件。**严格来说，文件系统是一种实现数据的存储、分级组织、访问和获取等操作的抽象数据类型。**

## 物理设备

### 磁带

![磁带](https://static.7wate.com/img/2023/04/13/919160de144ca.png)

> 来源：[录音磁带图片_百度百科](https://baike.baidu.com/pic/%E5%BD%95%E9%9F%B3%E7%A3%81%E5%B8%A6/19208887/1/a71ea8d3fd1f413446dceaf02c1f95cad0c85e51?fr=lemma#aid=1&pic=a71ea8d3fd1f413446dceaf02c1f95cad0c85e51)；仅学术引用，著作权归作者所有。

磁带存储是一种利用磁性材料存储数据的存储技术，具有可靠性高、容量大、成本低的特点，被广泛应用于数据备份、存档、长期存储等领域。

磁带存储的历史可以追溯到上世纪 50 年代，当时的磁带存储容量较小，读写速度较慢，主要用于存储机器指令和数据备份等应用。随着磁头技术、磁性材料技术的不断发展，磁带存储的容量和速度得到了大幅提升，使得其在数据备份、存档等领域得到了广泛应用。

![磁存储原理图](https://static.7wate.com/img/2023/04/13/16615f136d82c.png)

> 来源：[计算机组成原理](http://media4.open.com.cn/L603/fushi/0903/jisuanjzcyl/web/lesson/char4/j5.htm)

磁带存储的实现是通过将数据记录在磁带表面的磁性颗粒上，通过磁头读取磁带表面的磁性信号实现数据的读写。**磁带存储一般采用串行读写的方式，因此其读写速度相对较慢，但磁带存储的容量较大，可以达到数百TB的级别，且数据可靠性较高，可以长期保存数据。**

#### 优点

- 容量大，可达数百TB级别
- 成本低，适合大量数据备份和存储
- 数据可靠性高，不容易受到电磁干扰等因素的影响

#### 缺点

- 读写速度较慢，不适合实时读写和访问较频繁的应用
- 可靠性不足，长期存储容易出现数据腐败和损坏等问题，需要定期备份和检查
- 使用门槛较高，需要专业的设备和技术支持，不适合个人用户和小型企业使用

**磁带存储的主要应用场景是数据备份、存档和长期存储等领域。**在数据备份领域，磁带存储被广泛应用于数据中心、云服务提供商等场景，用于备份大量的数据和应用程序。在存档和长期存储领域，磁带存储可以用于保存重要的历史文档、音乐和影像等资料，具有容量大、可靠性高、成本低等优点。

在一些应用场景中，磁带存储的性能和特性比硬盘和固态硬盘更加适合，例如需要长期存储大量数据的场景，或者是需要备份和归档大量数据的场景。另外，在一些监管和合规性要求比较高的行业，如金融、医疗等领域，磁带存储也被广泛应用，因为**磁带存储具有防篡改、数据安全等特点。**

总的来说，磁带存储虽然在读写速度和可靠性等方面不如硬盘和固态硬盘，但是由于其容量大、成本低和长期可靠性等特点，使得其在某些特定的场景下仍然具有很大的应用前景。

### 光盘

![Melody 90min PLATiNUM CD disc.jpg](https://static.7wate.com/img/2023/04/13/ce44ff6b78a81.jpg)

> 来源：[File:Melody 90min PLATiNUM CD disc.jpg - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/File:Melody_90min_PLATiNUM_CD_disc.jpg)；仅学术引用，著作权归作者所有。

光盘存储是一种基于激光技术的数字存储介质，主要由光盘、CD-ROM、DVD 和 Blu-ray 等几种类型组成。它是一种非易失性存储介质，可以长期保存数据。

光盘存储的历史可以追溯到 20 世纪 80 年代初期，当时的光盘主要是音频光盘，主要用于存储音乐。随着激光技术的发展和数字化技术的普及，光盘存储也逐渐应用于数字存储领域。1985 年，Philips 和 Sony 公司共同推出了第一种数字光盘标准 CD（Compact Disc），从此，光盘存储开始进入数字时代。之后，随着技术的不断发展，CD-ROM、DVD 和 Blu-ray 等新一代光盘存储技术相继问世，容量和读取速度也得到了显著提升。

![光存储实现原理](https://static.7wate.com/img/2023/04/13/357e1bb6da04e.png)

> 来源：[一文读懂光储存技术及原理-面包板社区](https://www.eet-china.com/mp/a157461.html)；仅学术引用，著作权归作者所有。

光盘存储的实现主要基于激光技术。在光盘上刻有一系列螺旋状的凹槽，凹槽的长度和深度对应着数据的 1 和 0。当激光照射到光盘表面时，通过检测反射光的强弱和光波的相位变化，就可以判断凹槽的长度和深度，从而读取数据。不同类型的光盘，其光盘结构和读取方式也不同。

#### 优点

- 可靠性高：光盘存储的数据不受磁场影响，也不容易受到机械损坏的影响，具有较高的数据可靠性。
- 节约空间：光盘的体积小，易于存储和携带，适合用于小型数据的备份和存储。
- 价格低廉：相比其他存储介质，光盘存储的价格相对较低。

#### 缺点

- 容量有限：光盘存储的容量相对较小，最大只能达到几十 GB 的级别，不能满足大量数据存储和备份的需求。
- 写入速度慢：光盘存储的写入速度比硬盘和固态硬盘要慢得多，而且只能单向写入，不适合频繁的数据写入操作。
- 容易受到损坏：光盘存储的介质比较脆弱，容易受到划痕、污染等因素的影响，如果使用不当会导致数据损坏和丢失。
- 可靠性有限：光盘存储的可靠性相对较低，如果长时间不使用或存储环境较恶劣，光盘可能会失效或数据损坏。

**光盘存储适用于长期存储重要数据、分发软件、电影、音乐等媒体内容、随身携带备份个人数据或保存重要文档、兼容性广的数据存储需求。**虽然已经被硬盘和固态硬盘所取代，但在某些场合下仍然有其独特的应用优势。

### 机械硬盘

![Laptop-hard-drive-exposed.jpg](https://static.7wate.com/img/2023/04/13/0dc5ede099703.jpg)

> 来源：[File:Laptop-hard-drive-exposed.jpg - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/File:Laptop-hard-drive-exposed.jpg)；仅学术引用，著作权归作者所有。

机械硬盘（Hard Disk Drive，HDD）是一种数据存储设备，是计算机系统中最常用的存储媒介之一。它是一种使用磁盘片来存储数据的设备，通过机械臂上的读写头在盘片上读写数据。

#### 发展历史

机械硬盘存储的历史可以追溯到 20 世纪 50 年代，当时 IBM 公司研制出了第一个硬盘，容量为 5MB。随着计算机技术的不断进步，机械硬盘存储的容量、速度、可靠性等方面都得到了不断提升和改善，成为了计算机存储系统中不可或缺的一部分。

- 1956 年，IBM 305 RAMAC 是现代硬盘的雏形，容量仅为 5MB。
- 1973 年，IBM 3340 推出，拥有“温彻斯特”绰号，其存储单元恰好是当时“温彻斯特来福枪”的口径和填弹量。
- 1980 年，希捷科技公司开发出 5.25 英寸的 5MB 硬盘 ST506，这是面向台式机的首款硬盘产品。
- 1991 年，IBM 推出首款 3.5 英寸的 1GB 硬盘，应用了 MR（Magneto Resistive磁阻）技术，为硬盘容量的巨大提升奠定基础。
- 1997 年，IBM 应用 GMR（Giant Magneto Resistive，巨磁阻）技术，使磁头灵敏度进一步提升，进而提高存储密度。
- 2005 年，日立环储和希捷都宣布将开始大量采用磁盘垂直写入技术（perpendicular recording）。
- 2011 年，机械硬盘逐渐被固态硬盘所取代，希捷宣布收购三星旗下的硬盘业务。

2020 年截至现存主要硬盘制造商包括**西部数据、希捷、东芝、日立**等。

#### 数据接口

机械硬盘的接口是指将硬盘与计算机主板或控制卡连接的接口。早期的机械硬盘接口主要有 IDE (Integrated Drive Electronics) 和 SCSI（Small Computer System Interface）两种。目前，常见的机械硬盘接口主要包括 SATA（Serial ATA）和 SAS（Serial Attached SCSI）两种。

| 接口                                    | 传输速率     | 优点                                 | 缺点                         | 适用场景                     |
| --------------------------------------- | ------------ | ------------------------------------ | ---------------------------- | ---------------------------- |
| IDE（Integrated Drive Electronics）     | 最高133MB/s  | 支持 PATA 和 SATA 接口，兼容性好     | 传输速率较慢，线缆长度受限   | 早期的个人电脑、低端工作站等 |
| SCSI（Small Computer System Interface） | 最高 640MB/s | 高速传输，支持多设备连接，可扩展性强 | 价格较高，设置和维护较为复杂 | 高端服务器、存储阵列等       |
| SATA（Serial ATA）                      | 最高 6Gbps   | 价格低廉，易于使用和安装             | 传输速率较慢，线缆长度受限   | 个人电脑、工作站、NAS 等     |
| SAS（Serial Attached SCSI）             | 最高 12Gbps  | 高速传输，支持多设备连接             | 价格较高                     | 服务器、存储阵列等高端应用   |
| FC（Fibre Channel）                     | 最高 32Gbps  | 高速传输，支持多设备连接，可扩展性强 | 价格较高，设置和维护较为复杂 | 高端存储阵列、数据中心等     |

#### 硬盘尺寸

| 尺寸            | 容量       | 转速            | 缓存      | 平均寻道时间 | 内部传输速度 | 适用场景                                   |
| --------------- | ---------- | --------------- | --------- | ------------ | ------------ | ------------------------------------------ |
| 3.5英寸机械硬盘 | 160GB-16TB | 5400-15000转/分 | 8MB-256MB | 4-15ms       | 最高300MB/s  | 台式电脑，NAS，服务器，工作站等大型设备    |
| 2.5英寸机械硬盘 | 40GB-5TB   | 4200-15000转/分 | 8MB-128MB | 10-15ms      | 最高200MB/s  | 笔记本电脑，便携式硬盘，智能电视，游戏机等 |
| 1.8英寸机械硬盘 | 30GB-320GB | 4200-5400转/分  | 2MB-16MB  | 15-20ms      | 最高100MB/s  | 平板电脑，超极本，便携式媒体播放器等       |

#### 实现原理

机械硬盘存储的实现原理是基于磁性材料在磁场作用下的磁化性质。机械硬盘的磁性材料被划分为许多同心圆形的磁道，每个磁道又被划分为多个扇区，每个扇区存储着一定数量的数据。当计算机需要读取或写入数据时，机械硬盘的读写头会在磁盘上移动，将数据从磁盘读取或写入到存储器中。

机械硬盘的物理结构包括盘片、读写头、马达、控制器等组件。盘片是机械硬盘最重要的组件之一，用于存储数据。读写头则是机械硬盘的另一个重要组件，用于读取和写入数据。马达则用于旋转盘片，使得读写头能够顺利读取和写入数据。控制器则用于控制硬盘的读写和数据传输过程。

#### 设计结构

![机械硬盘物理结构](https://static.7wate.com/img/2023/04/13/73a9f4a829fe0.png)

![机械硬盘物理结构](https://static.7wate.com/img/2023/04/13/6b5eb8da87490.png)

> 来源：[File:Disk-structure2.svg - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/File:Disk-structure2.svg)；仅学术引用，著作权归作者所有。

机械硬盘是一种基于磁记录技术的数据存储设备，其物理结构主要包括磁头、盘片、马达、主轴、磁道、扇区、簇、块和分区表等部分。

- 磁头：机械硬盘中最为关键的部分之一，其作用是读写盘片上的数据。通常情况下，一块硬盘上会有多个磁头，每个磁头分别负责读写一侧或多侧盘片上的数据。
- 盘片：机械硬盘中存储数据的主要介质，它由铝合金或玻璃材料制成，表面上涂覆有磁性材料，用于记录数据。一块硬盘通常包含多个盘片，每个盘片分别分成若干个磁道和扇区，存储数据。
- 马达和主轴：是机械硬盘中的另外两个核心部件。马达用于带动盘片旋转，主轴则承载盘片和保持其旋转稳定。马达和主轴的性能直接影响到机械硬盘的读写速度和稳定性。
- 磁道：盘片表面的一个环形区域，类似于一条有向的螺旋线。每个磁道又被划分为多个扇区，用于存储数据。随着硬盘存储密度的提高，磁道数量也在不断增加。
- 簇：机械硬盘中的一个逻辑概念，它是由多个扇区组成的一个数据单元。簇的大小通常为几个扇区，取决于硬盘的格式化方式和操作系统的文件系统。
- 块：操作系统中对数据进行管理的最小单元，每个块通常有固定的大小，用于存储文件或其他数据。
- 分区表：硬盘中用于记录分区信息的一个特殊区域，它记录了硬盘分区的数量、大小和位置等信息。操作系统需要依据分区表来读取和写入硬盘上的数据。

#### MBR 和 GPT

机械硬盘的逻辑结构主要包括两种格式：MBR（Master Boot Record，主引导记录）和 GPT（GUID Partition Table，全局唯一标识分区表）。

MBR 是早期 PC 硬盘的标准分区方案，它将硬盘的分区信息保存在硬盘的第一个扇区中（即 0 号扇区），这个扇区的大小为 512 字节。MBR 可以分为两个部分：引导程序区和分区表。引导程序区存储了启动时需要加载的程序，分区表则记录了硬盘分区的信息，每个分区表项占用 16 字节，其中包括分区类型、起始扇区和分区大小等信息。MBR最多支持 4 个主分区或 3 个主分区和 1 个扩展分区。

GPT 是新一代硬盘分区标准，它将硬盘的分区信息保存在硬盘的第一个和第二个 LBA（Logical Block Addressing，逻辑块寻址）扇区中，每个 LBA 扇区的大小为512字节。GPT 采用了一个 128 位的唯一标识符（GUID）来标识分区表，因此支持更多的分区。每个 GPT 分区表项占用 128 字节，其中包括分区类型、GUID、起始扇区和分区大小等信息。GPT 最多支持 128 个分区。

|   特性   |            MBR             |                             GPT                              |
| :------: | :------------------------: | :----------------------------------------------------------: |
| 最大容量 |            2 TB            |                            9.4 ZB                            |
|  分区数  |          最多4个           |                          最多128个                           |
|  兼容性  | 较好，可用于BIOS和UEFI系统 |                    较好，主要用于UEFI系统                    |
| 系统要求 |     任何操作系统都支持     | Windows xp 64 位+、Mac OS X 10.6.5 及更高版本、Linux 和 UNIX |
|  安全性  |             差             | 支持在分区表中存储磁盘分区信息的完整性校验和，可检测分区表是否被修改 |

### 固态硬盘

![长江存储](https://static.7wate.com/img/2023/04/13/45b2bccd8d63d.png)

固态硬盘（Solid State Drive，SSD）是一种非易失性的存储设备，主要用于存储数据。与传统的机械硬盘（Hard Disk Drive，HDD）相比，它没有任何移动部件，因此在速度、耐用性和能源消耗方面具有明显优势。

#### 发展历史

固态硬盘的发展始于上世纪 50 年代，那时候的存储设备主要基于半导体技术。随着半导体技术的发展，SSD 逐渐成为计算机领域的一种主流存储设备。早期的 SSD 主要用于军事和航空领域，因为它们对性能和稳定性有很高的要求。随着技术的进步和成本的降低，SSD 已经成为消费者市场上的常见产品。

- 1978年，Toshiba 的工程师 Fujio Masuoka 发明了闪存技术，这是固态硬盘的基础技术。
- 1991年，SanDisk 推出首款基于 NAND 闪存的固态硬盘，容量为 20MB，主要应用于工业和军事领域。
- 1995年，IBM 发布了第一款 PCI 接口的固态硬盘，提高了数据传输速度。
- 2007年，Intel 推出了其首款主流固态硬盘——Intel X25-M，使用了 MLC（Multi-Level Cell）NAND 闪存技术，容量为 80GB，标志着固态硬盘开始进入消费者市场。
- 2008年，OCZ 推出了第一款支持 SATA 接口的固态硬盘，使得 SSD 更容易与现有计算机系统兼容。
- 2011年，高通和三星等公司联合制定了 UFS（Universal Flash Storage）标准，为移动设备提供了更高速度的存储解决方案。
- 2013年，NVMe 1.0 规范正式发布，为固态硬盘提供了更高性能的数据传输接口。
- 2015年，三星发布了其首款NVMe固态硬盘——Samsung 950 Pro，采用 M.2 接口和 V-NAND 技术，具有更高的读写速度和更小的尺寸。

2020 年主流的 SSD 厂商包括**三星、英特尔、西部数据、东芝、海力士和金士顿**等。

#### 数据接口

| 接口                                | 传输速度               | 优点                                   | 缺点                             | 适用场景                       |
| ----------------------------------- | ---------------------- | -------------------------------------- | -------------------------------- | ------------------------------ |
| PATA（Parallel ATA）                | 最高 133MB/s           | 成本较低，向后兼容性好                 | 速度较慢，数据线较粗，占用空间大 | 早期台式机和笔记本电脑         |
| SATA（Serial ATA）                  | 最高 6Gbps             | 速度较快，数据线较细，易安装，兼容性好 | 速度相对于 NVMe仍较慢            | 台式机和笔记本电脑             |
| NVMe（Non-Volatile Memory Express） | PCIe 3.0 x4：32 Gbit/s | 更高的传输速度，低延迟，可扩展性好     | 成本较高，需要主板支持           | 高性能台式机、笔记本、服务器等 |
|                                     | PCIe 4.0 x4：64 Gbit/s |                                        |                                  |                                |

#### 硬盘尺寸

固态硬盘有多种尺寸，如 2.5 英寸、1.8 英寸和 mSATA。2.5 英寸是最常见的尺寸，适用于笔记本电脑和台式机。1.8 英寸和 mSATA 主要用于超薄笔记本和移动设备。近年来，M.2（2230、2242、2260、2280）接口的 SSD 也越来越受欢迎，因为它们具有更小的尺寸和更高的性能。

***M.2 尺寸中的四位数字表示长度和宽度。**例如，M.2 2280 表示宽度为 22mm，长度为 80mm。此外，M.2  SSD 可能采用 SATA 或 NVMe 接口，需要根据设备的接口要求进行选择。*

#### 实现原理

固态硬盘（SSD）是一种非易失性的数据存储设备，它使用闪存（Flash Memory）作为存储介质。闪存具有较高的存储密度、较快的读取速度和较低的功耗，因此非常适合用于固态硬盘。与传统的机械硬盘（HDD）相比，固态硬盘没有机械运动部件，因此具有更高的读写速度、更低的延迟和更高的可靠性。

固态硬盘的核心组件包括控制器和闪存。控制器负责管理数据的读写操作、通信接口（如SATA或NVMe）、错误检测和校正（ECC）以及其他高级功能，如垃圾回收和可穿戴平衡。闪存中的数据存储在称为存储单元的微小晶体管中，数据通过改变存储单元的电子电压来表示不同的状态。

为了提高写入性能和延长硬盘寿命，固态硬盘采用了可穿戴平衡策略，并通过映射表将操作系统看到的逻辑地址映射到闪存中的物理地址。此外，固态硬盘还使用垃圾回收算法优化存储空间使用，以及接收操作系统的TRIM命令来提高写入性能。

#### 设计结构

![设计结构](https://static.7wate.com/img/2023/04/13/a650d29e84cf7.png)

> 来源：[深入浅出SSD - 注册以后还能改吧 - 博客园](https://www.cnblogs.com/lmhyhblog/p/12508849.html)；仅学术引用，著作权归作者所有。

1. 闪存芯片（Flash Memory Chips）：闪存是固态硬盘的核心存储介质，通常采用NAND型闪存。闪存具有较高的存储密度、较快的读取速度和较低的功耗。根据存储单元所存储的比特数，闪存可以分为SLC（单级单元）、MLC（多级单元）、TLC（三级单元）和QLC（四级单元）等类型。

| 类型 | 存储比特数  | 写入速度 | 寿命             | 容量密度 | 成本 | 适用场景                                                     |
| ---- | ----------- | -------- | ---------------- | -------- | ---- | ------------------------------------------------------------ |
| SLC  | 1 比特/单元 | 最快     | 最高（约10万次） | 低       | 高   | 企业级存储、高性能应用、工业级存储等要求高可靠性和耐用性的场景 |
| MLC  | 2 比特/单元 | 中等     | 高（约3万次）    | 中       | 中等 | 主流消费级和企业级应用，平衡了性能、耐用性和成本             |
| TLC  | 3 比特/单元 | 较慢     | 中等（约1万次）  | 高       | 较低 | 主流消费级存储，适用于大容量、低成本的应用场景               |
| QLC  | 4 比特/单元 | 最慢     | 最低（约1千次）  | 最高     | 最低 | 面向大容量存储需求，以成本为主要考虑因素的应用场景           |

1. 控制器（Controller）：控制器是固态硬盘的大脑，负责管理数据的读写操作、通信接口（如 SATA 或NVMe）、错误检测和校正（ECC）以及其他高级功能，如垃圾回收、可穿戴平衡和 AES 加密。控制器的性能对固态硬盘的整体性能有很大影响。
2. 缓存（Cache）：部分固态硬盘配置有 DRAM 或 SRAM 作为缓存，用于临时存储数据以提高数据传输速度。缓存还可以用于存储映射表（Mapping Table），用于记录逻辑地址和物理地址之间的映射关系。
3. 电源电路（Power Circuitry）：固态硬盘的电源电路负责将来自主板的电源转换为适用于控制器和闪存芯片的电压。
4. 接口（Interface）：固态硬盘需要一个接口与主板相连，以便于数据传输和电源供应。常见的接口类型包括SATA、mSATA、M.2（支持SATA和NVMe协议）以及 U.2 等。
5. 固件（Firmware）：固态硬盘的固件包含一组存储在控制器上的指令，用于控制和管理硬盘的各种功能。固件可以通过制造商发布的更新来优化性能和修复已知问题。
6. 散热（Thermal Management）：高性能的固态硬盘在运行过程中可能会产生较高的热量，因此需要采取一定的散热措施。散热解决方案包括散热片、热导管以及与主板的热接触等。

总之，固态硬盘的设计结构由闪存芯片、控制器、缓存、电源电路、接口、固件以及散热系统等组件组成。这些组件共同协作，实现了高速、低功耗、高可靠性和抗震性等优点。相较于传统的机械硬盘，固态硬盘在许多应用场景中具有明显优势，特别是在高性能需求、移动设备和企业级应用等方面。随着闪存技术的不断发展，固态硬盘的容量和性价比也在逐渐提高，使得固态硬盘成为越来越多用户的首选存储设备。

### HHD 和 SSD

|          | 机械硬盘（HDD）              | 固态硬盘（SSD）                    |
| -------- | ---------------------------- | ---------------------------------- |
| 存储原理 | 磁盘旋转，磁头读写数据       | 闪存芯片（无机械运动部件）         |
| 读写速度 | 较慢                         | 更快                               |
| 寿命     | 受机械部件磨损影响，可能较短 | 一般较长，但受闪存写入次数限制     |
| 噪音     | 由于机械部件运动产生噪音     | 几乎无噪音                         |
| 耗能     | 由于机械部件运动，耗能较高   | 耗能较低                           |
| 抗震性   | 受机械部件影响，抗震性较差   | 抗震性能好                         |
| 延迟     | 由于机械运动，延迟较高       | 延迟较低                           |
| 容量     | 通常容量较大，成本低         | 容量相对较小，但快速发展中         |
| 价格     | 相对便宜                     | 价格较高，但逐渐降低               |
| 适用场景 | 大容量存储、低成本应用       | 高性能需求、移动设备、企业级应用等 |

### 长江存储

长江存储（Yangtze Memory Technologies Co., Ltd.，YMTC）是一家中国领先的半导体存储产品制造商，总部位于武汉市东湖新技术开发区。长江存储成立于2016年，由中国国家集成电路产业投资基金、武汉市政府、合肥市政府和清华紫光集团共同投资成立。

- 2016年，长江存储正式成立。
- 2017年，长江存储研发成功32层堆叠3D NAND闪存。
- 2018年，公司成功研发64层堆叠3D NAND闪存，实现量产。
- 2019年，长江存储发布128层3D NAND闪存。
- 2020年，长江存储正式宣布128层3D NAND闪存量产。
- 2021年，长江存储的128层闪存开始广泛应用于客户端SSD产品。

长江存储的主要发展方向是提高闪存产品的性能和容量，降低生产成本，不断扩大市场份额。公司将继续专注于3D NAND闪存技术的研发和量产，努力实现更高层次的堆叠技术，以满足客户在各种应用场景的需求。此外，长江存储也将积极拓展国际市场，与全球半导体产业链深度合作，提高国产存储器在全球市场的竞争力。

长江存储是中国领先的半导体存储制造商，自成立以来，公司在3D NAND闪存技术领域取得了显著成果。通过不断提高产品性能、降低成本以及拓展国际市场，长江存储正努力在全球存储产业中树立中国品牌的地位，推动国产半导体产业的发展。

***国产之光，冲冲冲！***

## 文件系统

在 Linux 系统中支持多种文件系统，如：Ext2、Ext3、Ext4、XFS、Btrfs、NTFS、FAT32、ISO 9660、NFS 等。

| 系统     | 全拼                                     | 功能                                                         | 优点                                                         | 用途                                                      |
| -------- | ---------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | --------------------------------------------------------- |
| Ext2     | Second Extended File System              | 提供基本的文件存储功能                                       | 简单，速度较快，可靠性高                                     | 适用于小型存储设备，如闪存卡                              |
| Ext3     | Third Extended File System               | 在Ext2基础上增加了日志功能                                   | 文件系统可靠性更高，具有较好的容错能力                       | 适用于大多数Linux发行版，以及需要可靠数据存储的服务器环境 |
| Ext4     | Fourth Extended File System              | 在Ext3基础上增加了更多的特性，如更大的文件系统和更高的性能   | 支持大容量文件和高性能文件系统访问                           | 适用于大型服务器和高性能计算机                            |
| XFS      | XFS File System                          | 高性能文件系统，支持大容量文件和高吞吐量应用                 | 速度快，可靠性高，适合高性能计算和大型存储设备               | 适用于需要大容量和高性能访问的服务器环境                  |
| Btrfs    | B-tree File System                       | 先进的文件系统，支持快照、数据压缩和多个设备的联合文件系统等功能 | 可靠性高，能够在多个设备之间提供容错性                       | 适用于需要高效数据管理和可靠存储的服务器和桌面环境        |
| NTFS     | New Technology File System               | Windows操作系统上的文件系统，支持文件和目录的权限控制和加密等功能 | 可以处理很大的文件系统，能够在Windows和Linux之间进行数据传输 | 适用于需要与Windows系统交互的Linux系统                    |
| FAT32    | File Allocation Table 32-bit             | 一种老旧的文件系统，支持大容量的存储设备                     | 可以在不同的操作系统之间进行数据传输，通常用于移动设备和便携式存储介质上 | 适用于小型存储设备，如USB闪存盘和SD卡                     |
| ISO 9660 | International Standard Organization 9660 | 用于光盘文件系统                                             | 支持只读访问，可以在不同的操作系统之间进行数据传输           | 适用于在CD和DVD上发布数据的场景                           |
| NFS      | Network File System                      | 一种网络文件系统，可以让不同的机器上的用户共享文件系统       | 能够在不同的计算机之间共享文件和目录，提供高度的数据访问性能 | 适用于需要在多个计算机之间共享文件的网络环                |

### 层次结构

![Linux 文件层次结构图](https://static.7wate.com/img/2023/04/13/a44be4559ea26.png)

> 来源：[Linux 文件系统结构 - Strong在线文档库](https://www.hanzz.red/archives/linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84)；仅学术引用，著作权归作者所有。

在 Linux 系统中，文件系统采用了一种层次结构来组织文件和目录，这种层次结构称为**文件系统层次结构**（Filesystem Hierarchy Standard，FHS）。FHS 是一种标准化的文件系统层次结构，规定了在不同的 Linux 系统中应该如何组织文件和目录，以保证文件系统的一致性和兼容性。

| 目录名 | 全拼                  | 功能                         | 用途                                                         |
| ------ | --------------------- | ---------------------------- | ------------------------------------------------------------ |
| /      | Root                  | 根目录                       | 包含所有其他目录和文件的根目录                               |
| /bin   | Binary                | 存放系统二进制可执行文件     | 包含最基本的系统命令                                         |
| /boot  | Boot                  | 存放启动加载程序和内核       | 包含启动Linux系统所必需的文件                                |
| /dev   | Device                | 存放设备文件                 | 包含Linux系统中所有的设备文件，如硬盘、键盘、鼠标等          |
| /etc   | Etcetera              | 存放系统配置文件             | 包含Linux系统中所有的系统配置文件，如网络配置文件、用户账号配置文件等 |
| /home  | Home                  | 存放用户家目录               | 包含所有用户的家目录                                         |
| /lib   | Library               | 存放系统共享库文件           | 包含系统运行时所需要的一些库函数                             |
| /media | Media                 | 存放可移动介质挂载点         | 包含可移动介质的挂载点，如U盘、光盘等                        |
| /mnt   | Mount                 | 存放挂载点                   | 包含文件系统挂载点，用于临时挂载其他文件系统                 |
| /opt   | Optional              | 存放第三方应用程序           | 包含安装在系统中的第三方应用程序                             |
| /proc  | Process               | 存放进程相关信息             | 包含Linux系统中所有进程的相关信息                            |
| /root  | Root                  | root用户家目录               | 仅限root用户访问的家目录                                     |
| /run   | Run                   | 存放运行时信息               | 包含运行时所需要的各种信息，如进程号等                       |
| /sbin  | System Binary         | 存放系统管理二进制可执行文件 | 包含系统管理员使用的基本命令和系统管理工具                   |
| /srv   | Service               | 存放服务相关数据             | 包含服务相关的数据，如Web服务的网站文件                      |
| /sys   | System                | 存放系统设备文件             | 包含系统中所有设备的相关信息                                 |
| /tmp   | Temporary             | 存放临时文件                 | 包含系统中各种临时文件                                       |
| /usr   | Unix Shared Resources | 存放Unix共享资源             | 包含系统中大多数应用程序、库文件和文档等                     |
| /var   | Variable              | 存放经常变化的文件           | 包含系统中经常变化的文件，如日志文件、数据库文件等           |

### 文件元数据

**在 Linux 系统中，每个文件都有其对应的元信息，也称为元数据(metadata)。**元数据包含了文件的基本属性，如文件的创建时间、访问时间、修改时间，文件大小，文件所有者和所属组，文件的权限等等。

以下是一些常见的文件元数据：

- 文件名：文件的名字，用于标识文件。
- 文件类型：表示文件的类型，如普通文件、目录、链接文件、字符设备、块设备等等。
- 文件大小：表示文件的大小，以字节为单位。
- 时间戳：记录了文件的创建时间、访问时间、修改时间等信息。
- 文件权限：文件所有者、所属组、其他用户对文件的读、写、执行权限。
- 文件所有者和所属组：表示文件的所有者和所属组。
- 文件状态：如 inode 号码、硬链接数等。

在 Unix 和类 Unix 操作系统中 文件系统中，每个文件或目录都有一个inode号码，它是唯一的，由文件系统分配，文件名只是 inode 的别名而已。当我们打开一个文件时，实际上是根据该文件名找到对应的 inode，然后通过 inode 读取文件的数据。

index node (inode) 是 Unix 和类 Unix 操作系统中的一个重要概念，它是文件系统中用来存储文件或目录的元数据信息的一种数据结构，每个文件或目录都对应一个唯一的 inode。下面是一个示例 inode 表格：

| 文件类型 | inode号 | 大小 | 拥有者 | 权限 | 访问时间 | 修改时间 | 创建时间 |
| -------- | ------- | ---- | ------ | ---- | -------- | -------- | -------- |
| 普通文件 | 12345   | 1KB  | root   | 644  | 2022/3/1 | 2022/3/2 | 2022/3/1 |

### 物理设备文件

**在 Linux 系统中，一切都是文件**，包括硬件设备也不例外。这是因为在 Linux 中，硬件设备被抽象成了一种特殊的文件类型，称为设备文件（Device file）。设备文件用于对硬件设备进行读写操作，类似于普通文件的读写操作。设备文件分为两种类型：

- **块设备文件**：对应的硬件设备是以块为单位进行读写的设备，例如硬盘、U盘等；
- **字符设备文件**：对应的硬件设备是以字符为单位进行读写的设备，例如键盘、鼠标、打印机等。

在 Linux 系统中，每个设备文件都有一个对应的设备文件名，该文件名通常位于 /dev 目录下，不同的硬件设备会有不同的设备文件名。通过访问设备文件，用户可以对硬件设备进行操作。例如，如果想要读取硬盘的数据，用户可以通过访问对应的设备文件（如 /dev/sda）来读取数据，而不需要关心具体的物理硬盘是什么型号、连接方式等等。这种抽象的方式让用户更方便地使用硬件设备，并且使得操作系统能够更好地管理硬件设备。

| 硬件设备                   | 命名规则             |
| -------------------------- | -------------------- |
| IDE 接口硬盘               | /dev/hd[a-d]         |
| SCSI、SATA、U盘            | /dev/sd[a-z]         |
| KVM/QEMU 虚拟设备          | /dev/vd[a-z]         |
| 软盘                       | /dev/fd[0-1]         |
| 打印机                     | /dev/lp[0-15]        |
| CD/DVD 光盘驱动器          | /dev/cdrom           |
| 鼠标设备                   | /dev/mouse           |
| SCSI 接口磁带机或 IDE 接口 | /dev/st0 或 /dev/ht0 |

### 磁盘挂载

![磁盘挂载流程](https://static.7wate.com/img/2023/04/13/ad3f9a8dfa3f1.png)

#### 0. 插入新硬盘

将新硬盘插入计算机的硬盘插槽中，并连接好数据线和电源线。

#### 1. 查看硬盘信息

确认新硬盘的设备名称：可以使用 `fdisk -l` 命令或者 `lsblk` 命令来列出系统中的所有硬盘设备，找到新硬盘的设备名称。

```shell
[root@rhel ~]# lsblk
NAME          MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
nvme0n1       259:0    0   64G  0 disk
├─nvme0n1p1   259:1    0    1G  0 part /boot
└─nvme0n1p2   259:2    0   63G  0 part
  ├─rhel-root 253:0    0 39.7G  0 lvm  /
  ├─rhel-swap 253:1    0  3.9G  0 lvm  [SWAP]
  └─rhel-home 253:2    0 19.4G  0 lvm  /home
nvme0n2       259:3    0    8G  0 disk 👈
[root@rhel ~]# fdisk -l /dev/nvme0n2
Disk /dev/nvme0n2：8 GiB，8589934592 字节，16777216 个扇区
磁盘型号：VMware Virtual NVMe Disk
单元：扇区 / 1 * 512 = 512 字节
扇区大小(逻辑/物理)：512 字节 / 512 字节
I/O 大小(最小/最佳)：512 字节 / 512 字节
```

#### 2.创建分区

如果新硬盘未被分区，则需要先创建分区。可以使用 `fdisk`  命令来创建分区，然后按照提示创建分区。

```shell
[root@rhel ~]# fdisk /dev/nvme0n2

欢迎使用 fdisk (util-linux 2.37.4)。
更改将停留在内存中，直到您决定将更改写入磁盘。
使用写入命令前请三思。

设备不包含可识别的分区表。
创建了一个磁盘标识符为 0x70f8d313 的新 DOS 磁盘标签。

命令(输入 m 获取帮助)：n 👈
分区类型
   p   主分区 (0 primary, 0 extended, 4 free)
   e   扩展分区 (逻辑分区容器)
选择 (默认 p)：p 👈
分区号 (1-4, 默认  1): 1 👈
第一个扇区 (2048-16777215, 默认 2048):2048 👈
最后一个扇区，+/-sectors 或 +size{K,M,G,T,P} (2048-16777215, 默认 16777215): +1g 👈

创建了一个新分区 1，类型为“Linux”，大小为 1 GiB。

命令(输入 m 获取帮助)：w 👈
分区表已调整。
将调用 ioctl() 来重新读分区表。
正在同步磁盘。
```

#### 3.格式化分区

分区创建完成后，需要将分区格式化为文件系统才能挂载。可以使用 `mkfs` 命令来格式化分区，比如可以使用 `mkfs.ext4 /dev/nvme0n2p1`命令将 `/dev/nvme0n2p1` 分区格式化为 ext4 文件系统。

```shell
[root@rhel ~]# lsblk
NAME          MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
nvme0n1       259:0    0   64G  0 disk
├─nvme0n1p1   259:1    0    1G  0 part /boot
└─nvme0n1p2   259:2    0   63G  0 part
  ├─rhel-root 253:0    0 39.7G  0 lvm  /
  ├─rhel-swap 253:1    0  3.9G  0 lvm  [SWAP]
  └─rhel-home 253:2    0 19.4G  0 lvm  /home
nvme0n2       259:3    0    8G  0 disk
└─nvme0n2p1   259:5    0    1G  0 part 👈
[root@rhel ~]# mkfs.ext4 /dev/nvme0n2p1
mke2fs 1.46.5 (30-Dec-2021)
创建含有 262144 个块（每块 4k）和 65536 个inode的文件系统
文件系统UUID：28337fe9-2ec1-4d39-9001-27595dd569bf
超级块的备份存储于下列块：
        32768, 98304, 163840, 229376

正在分配组表： 完成
正在写入inode表： 完成
创建日志（8192 个块）完成
写入超级块和文件系统账户统计信息： 已完成
```

#### 4.创建挂载点

在 Linux 中，需要先创建一个目录，作为挂载点，使用 `mount` 命令将分区挂载到该目录下。

```shell
[root@rhel ~]# mkdir /mnt/newdisk-1gb
[root@rhel ~]# mount /dev/nvme0n2p1 /mnt/newdisk-1gb/
[root@rhel ~]# df -h
文件系统               容量  已用  可用 已用% 挂载点
devtmpfs               4.0M     0  4.0M    0% /dev
tmpfs                  1.8G     0  1.8G    0% /dev/shm
tmpfs                  726M  9.1M  717M    2% /run
/dev/mapper/rhel-root   40G  2.2G   38G    6% /
/dev/mapper/rhel-home   20G  171M   20G    1% /home
/dev/nvme0n1p1        1014M  244M  771M   24% /boot
tmpfs                  363M     0  363M    0% /run/user/0
/dev/nvme0n2p1         974M   24K  907M    1% /mnt/newdisk-1gb 👈
```

#### 5.配置自动挂载

```shell
[root@rhel ~]# df -h
文件系统               容量  已用  可用 已用% 挂载点
devtmpfs               4.0M     0  4.0M    0% /dev
tmpfs                  1.8G     0  1.8G    0% /dev/shm
tmpfs                  726M  9.1M  717M    2% /run
/dev/mapper/rhel-root   40G  2.2G   38G    6% /
/dev/mapper/rhel-home   20G  171M   20G    1% /home
/dev/nvme0n1p1        1014M  244M  771M   24% /boot
tmpfs                  363M     0  363M    0% /run/user/0
/dev/nvme0n2p1         974M   24K  907M    1% /mnt/newdisk-1gb
[root@rhel ~]# blkid | grep 0n2
/dev/nvme0n2p1: UUID="28337fe9-2ec1-4d39-9001-27595dd569bf" TYPE="ext4" PARTUUID="70f8d313-01"
[root@rhel ~]# echo "UUID=28337fe9-2ec1-4d39-9001-27595dd569bf /mnt/newdisk-1gb ext4 defaults 0 0" >> /etc/fstab
[root@rhel ~]# tail -n 1 /etc/fstab
UUID=28337fe9-2ec1-4d39-9001-27595dd569bf /mnt/newdisk-1gb ext4 defaults 0 0
[root@rhel ~]# mount -a
[root@rhel ~]# reboot
======================== 重启后 ========================
[root@rhel ~]# df -h
文件系统               容量  已用  可用 已用% 挂载点
devtmpfs               4.0M     0  4.0M    0% /dev
tmpfs                  1.8G     0  1.8G    0% /dev/shm
tmpfs                  726M  9.1M  717M    2% /run
/dev/mapper/rhel-root   40G  2.2G   38G    6% /
/dev/mapper/rhel-home   20G  171M   20G    1% /home
/dev/nvme0n2p1         974M   24K  907M    1% /mnt/newdisk-1gb 👈
/dev/nvme0n1p1        1014M  244M  771M   24% /boot
tmpfs                  363M     0  363M    0% /run/user/0
```

### 日常巡检

![日常巡检流程](https://static.7wate.com/img/2023/04/13/8e3674e1b65a9.png)

#### 查询磁盘空间使用情况

使用 `df` 命令来查询文件系统的空间使用情况。

```shell
[root@rhel ~]# df -h
文件系统               容量  已用  可用 已用% 挂载点
devtmpfs               4.0M     0  4.0M    0% /dev
tmpfs                  1.8G     0  1.8G    0% /dev/shm
tmpfs                  726M  9.1M  717M    2% /run
/dev/mapper/rhel-root   40G  2.3G   38G    6% /
/dev/mapper/rhel-home   20G  171M   20G    1% /home
/dev/nvme0n2p1         974M   24K  907M    1% /mnt/newdisk-1gb
/dev/nvme0n1p1        1014M  244M  771M   24% /boot
tmpfs                  363M     0  363M    0% /run/user/0
```

#### 查询目录空间使用情况

使用 `du` 命令来查询指定目录的空间使用情况。

```shell
[root@rhel ~]# du -h /var | head -n 10
488K    /var/lib/dnf
54M     /var/lib/rpm
0       /var/lib/games
0       /var/lib/misc
0       /var/lib/rpm-state/kernel
0       /var/lib/rpm-state
48K     /var/lib/alternatives
0       /var/lib/selinux/tmp
36K     /var/lib/selinux/targeted/active/modules/100/abrt
20K     /var/lib/selinux/targeted/active/modules/100/accountsd
```

#### 磁盘性能监测

sysstat（System Statistics）是一个系统性能监控工具，它包含了一系列的工具和报告，可以用来监测系统负载、CPU 使用率、内存使用率、网络活动等系统性能指标。sysstat 提供了一些常用的命令行工具，包括 sar、iostat、mpstat、pidstat 等，这些工具可以周期性地获取系统的性能指标数据，并将数据保存在文件中。用户可以使用这些数据来分析系统的负载情况、瓶颈所在等，进一步优化系统性能。

sysstat 的主要功能包括：

- 提供了 sar 工具，可以对系统进行多方面的监控，如 CPU 使用率、内存使用率、IO 使用率等。
- 提供了 iostat 工具，可以监控磁盘 I/O 活动情况。
- 提供了 mpstat 工具，可以监控 CPU 的性能指标，如使用率、上下文切换、中断数等。
- 提供了 pidstat 工具，可以监控进程的性能指标，如 CPU 使用率、内存使用率、IO 活动情况等。
- 提供了 sadf 工具，可以将 sar 工具的输出转换成其他格式，如 CSV、XML、JSON 等。
- 支持将性能监控数据保存到文件中，并提供了一些工具，如 sadc、sa1、sa2 等，来周期性地收集性能数据。
- 支持使用系统日志守护程序来管理和处理系统日志，如 syslogd、rsyslogd 等。

总之，sysstat 提供了一系列强大的性能监控工具和报告，可以帮助用户深入了解系统的性能状况，并及时识别并解决性能瓶颈，从而提高系统的稳定性和可靠性。

## 权限和安全

Linux 文件系统的权限和安全主要可以分为**四个部分：常用权限控制、特殊权限控制、隐藏权限控制和 SELinux 权限控制。**

### 常用权限

**Linux 系统中有三种基本的权限：读（r，read）、写（w，write）和执行（x，execute）**。也可以使用数字来表示文件或目录的权限。每个权限用一个数字表示，分别为 4、2 和 1，分别代表读、写和执行权限。通过将这些数字相加，可以得到一个三位数的数字，用于表示用户、组和其他用户的权限。这些权限分别适用于文件和目录。权限可以分为三组，分别为：**用户（u，user），组（g，group）和其他（o，others）**。

- 文件权限设置为 -rw-r--r--：`chmod 644 file.txt`、`chmod u=rw,g=r,o=r file.txt`
- 文件所有者设置执行权限：`chmod u+x file.txt`
- 文件所有组去除写入和执行权限：`chmod g-wx file.txt`
- 文件其他用户设置只读权限：`chmod o=r file.txt`

*注意：chmod `+` 表示添加权限，`-` 表示删除权限，`=` 表示设置权限。*

```shell
drwxr-xr-x 1 root root 4096 Dec 10 03:15 boot
 
这是一个目录（d开头），权限为rwxr-xr-x，所有者为root，所属组也为root，大小为4096字节，创建时间为12月10日 03:15。

所有者（root）具有读、写和执行权限（rwx）
所属组（root）和其他用户具有读和执行权限（r-x）
总的来说，这个目录的权限是755（rwxr-xr-x），所有者有最高的权限，可以对目录进行任何操作，而组和其他用户只有读和执行权限。
```

| 权限     | 数字 | 文件权限                         | 目录权限                               |
| -------- | ---- | -------------------------------- | -------------------------------------- |
| 读（r）  | 4    | 允许用户读取文件内容             | 允许用户查看目录内容                   |
| 写（w）  | 2    | 允许用户修改文件内容             | 允许用户在目录中创建、删除和重命名文件 |
| 执行 (x) | 1    | 允许用户执行文件（如程序或脚本） | 允许用户进入目录                       |

### 特殊权限

Linux 系统中，特殊权限是指那些不同于常规文件和目录权限（读、写、执行）的权限。这些特殊权限有助于控制用户或进程在访问或操作文件时所拥有的权限。

- 文件设置粘滞位：`chmod o+t`
- 文件取消粘滞位：`chmod o-t`

| 特殊权限            | 示例        | 描述                                                         |
| ------------------- | ----------- | ------------------------------------------------------------ |
| Setuid (suid)       | `chmod u+s` | 当文件具有 setuid 权限时，任何用户在执行该文件时都将获得文件所有者的权限。 |
| Setgid (sgid)       | `chmod g+s` | 当文件具有 setgid 权限时，用户可以以文件所属组的权限执行文件。对于目录，具有 setgid 权限的目录下创建的文件和子目录自动继承该目录的组。 |
| 粘滞位 (Sticky Bit) | `chmod o+t` | 当为目录设置粘滞位时，只有文件所有者和 root 用户可以删除或重命名该目录中的文件。 |

### 隐藏权限

Linux 系统中，隐藏权限通常指那些不容易被用户发现的权限。这些权限可以通过 `chattr` 命令设置，并使用 `lsattr` 命令查看。隐藏权限有助于保护文件免受意外删除或修改，从而增强 Linux 系统的安全性。

- 文件设置不可修改（i）权限：`chattr +i example.txt`
- 文件取消不可修改（i）权限：`chattr -i example.txt`
- 查看文件的隐藏权限：`lsattr example.txt`

| 隐藏权限           | chattr 参数 | 作用                                                     |
| ------------------ | ----------- | -------------------------------------------------------- |
| Immutable          | i           | 无法修改文件，目录中子文件内容可修改，不能新建或删除文件 |
| Append only        | a           | 仅允许追加内容，无法覆盖/删除内容                        |
| Sync               | S           | 文件内容变更后立即同步到硬盘                             |
| Secure deletion    | s           | 彻底删除，不可恢复（用 0 填充原文件所在硬盘区域）        |
| No update of atime | A           | 不再修改文件或目录的最后访问时间                         |
| No update of btime | b           | 不再修改文件或目录的存取时间                             |
| Error checking     | D           | 检查压缩文件中的错误                                     |
| No dump            | d           | 使用 dump 命令备份时忽略本文件/目录                      |
| Compression        | c           | 默认将文件或目录进行压缩                                 |
| Undeletion         | u           | 删除后保留在硬盘中的数据，方便恢复                       |
| Tail-merging       | t           | 让文件系统支持尾部合并                                   |
| Direct access      | x           | 可以直接访问压缩文件中的内容                             |

## 系统分区

系统分区（system partition）是指计算机中用于存放操作系统和操作系统所需的系统文件和程序的分区，也称为根分区（root partition）。在计算机中，系统分区是最基本的分区之一，是计算机系统正常运行的核心部分。

在 PC 机上，系统分区通常使用 MBR（Master Boot Record）或 GPT（GUID Partition Table）格式的分区表来管理磁盘分区。MBR 是一种旧的分区表格式，它支持最多 4 个主分区或 3 个主分区和 1 个扩展分区，每个分区表项占用 16 个字节。GPT 是一种新的分区表格式，支持最多 128 个分区，每个分区表项占用 128 个字节，可以支持超过 2TB 的硬盘容量。

在 Linux 系统中，系统分区通常包括 /boot、/、/usr、/var、/tmp、/home 等分区。其中，/boot 分区包含了操作系统的内核和引导程序；/ 分区包含了操作系统及其所有文件和程序；/usr 分区包含了系统的共享程序和文件；/var 分区包含了系统运行时生成的变量数据；/tmp 分区是临时文件存储分区；/home 分区则是存放用户数据和个人文件的分区。

在进行磁盘分区时，应该根据计算机的实际情况来选择合适的分区表格式和分区方案，并为每个分区分配正确的类型和大小。在安装操作系统时，应该按照系统要求来分配磁盘空间和设置系统分区，以确保计算机系统的正常运行和数据安全。

### 分区表

分区表（Partition Table Type）是计算机中用于管理硬盘分区的数据结构，用于记录硬盘上分区的信息和布局方式。计算机操作系统通过读取分区表来获取硬盘分区的信息，并根据分区表中的信息对硬盘进行分区、格式化、挂载等操作。分区表通常存储在硬盘的某个特定位置，例如 MBR（Master Boot Record）分区表通常存储在硬盘的第一个扇区，GPT（GUID Partition Table）分区表则存储在硬盘的最后一个扇区。

分区表的历史可以追溯到早期的操作系统，例如 MS-DOS、Windows 95 等。**早期的操作系统并没有支持硬盘分区的概念，所有的数据都存储在硬盘的同一个分区中。这样做有许多限制，例如数据管理和备份都不方便，硬盘容量也受到了限制。**

为了克服这些限制，早期的操作系统开始使用分区表来管理硬盘分区。早期的分区表格式包括 MBR 分区表和 APM（Apple Partition Map）分区表等。MBR 分区表是最早被广泛使用的分区表格式之一，最早出现于 1983年，可以管理硬盘上的最多 4 个主分区或 3 个主分区和 1 个扩展分区。APM 分区表是苹果公司开发的一种分区表格式，用于管理 Macintosh 计算机上的硬盘分区。

随着计算机硬件的不断升级，MBR 分区表已经无法满足大容量硬盘的管理需求，因此新的分区表格式应运而生。GPT 分区表是一种较新的分区表格式，它使用全球唯一的 GUID 标识硬盘上的分区信息，支持的最大硬盘容量为EB（exabyte）级别，最多可以管理 128 个分区。GPT 分区表还支持热插拔、校验和、备份分区表等特性。同时，由于 GPT 分区表使用了 GUID 标识硬盘上的分区信息，因此 GPT 分区表比 MBR 分区表更加安全可靠。

#### MBR 分区

MBR（Master Boot Record）是一种分区表结构，位于硬盘的第一个扇区（通常为磁盘的第一个物理扇区，即LBA 0）。MBR 包含了操作系统启动引导代码（Bootloader）和分区表信息。MBR 的主要作用是在计算机启动时加载操作系统。

MBR 分区方案的历史可以追溯到 1983 年，当时 IBM PC/AT 发布。当时的 PC/AT 使用 16 位 Intel 80286 处理器，最大寻址空间为 16 MB。随着硬盘容量的增长，MBR 分区方案逐渐显现出容量限制。因此，GPT（GUID Partition Table）分区方案应运而生，取代了 MBR。

MBR分区表结构包括以下部分：

1. Bootloader（446字节）：存放引导加载程序，负责将操作系统从磁盘加载到内存。
2. 分区表（64字节）：记录了硬盘上分区的信息，如分区类型、分区大小、分区位置等。MBR支持最多四个主分区或三个主分区加一个扩展分区。扩展分区可进一步划分为多个逻辑分区。
3. 签名（2字节）：一个固定的值（0x55AA），表示这是一个有效的MBR分区表。

##### 标准 MBR 结构

| 字节偏移 (Hex) | 字节偏移 (Oct) | 字节偏移 (Dec) | 长度 (Byte) | 描述                                |
| -------------- | -------------- | -------------- | ----------- | ----------------------------------- |
| 0x000          | 0000           | 0              | 446         | Bootloader（引导加载程序）          |
| 0x1BE          | 0676           | 446            | 16          | 主分区1（分区表条目1）              |
| 0x1CE          | 0706           | 462            | 16          | 主分区2（分区表条目2）              |
| 0x1DE          | 0736           | 478            | 16          | 主分区3（分区表条目3）              |
| 0x1EE          | 0766           | 494            | 16          | 主分区4（分区表条目4）              |
| 0x1FE          | 0776           | 510            | 2           | 签名（0x55AA，表示有效的MBR分区表） |

##### 分区表条目结构

| 字节偏移 (Hex) | 字节偏移 (Oct) | 字节偏移 (Dec) | 长度 (Byte) | 描述                         |
| -------------- | -------------- | -------------- | ----------- | ---------------------------- |
| 0x00           | 000            | 0              | 1           | 引导标识符（80h为活动分区）  |
| 0x01           | 001            | 1              | 3           | 起始磁头（柱面、磁头、扇区） |
| 0x04           | 004            | 4              | 1           | 分区类型                     |
| 0x05           | 005            | 5              | 3           | 结束磁头（柱面、磁头、扇区） |
| 0x08           | 010            | 8              | 4           | 起始LBA地址                  |
| 0x0C           | 014            | 12             | 4           | 分区扇区数                   |

##### MBR 优点

1. 兼容性强：MBR 分区方案兼容几乎所有现有的操作系统和硬件。
2. 简单易用：MBR 分区表结构简单，易于操作和维护。

##### MBR 缺点

1. 容量限制：MBR 分区方案最大支持 2TB（2^32扇区 * 512字节/扇区）的硬盘容量。
2. 分区数量限制：**MBR 最多支持四个主分区，或三个主分区加一个扩展分区。**对于现代计算机而言，这一限制可能较为局限。
3. 无备份机制：MBR 没有备份分区表的机制，一旦 MBR 损坏，可能导致数据丢失。

MBR 分区表最初设计时只考虑了 512 字节的容量限制，因此无法识别超过 2TB 的硬盘。尽管 MBR 的兼容性较好，但随着计算机技术的发展，MBR 的局限性逐渐显现。未来，MBR 可能会在特定场景下继续使用，例如在旧式硬件或操作系统上。然而，随着 GPT 的普及和技术进步，MBR 的应用范围将会逐渐缩小。

总之，MBR 分区方案在过去的计算机技术发展中扮演了重要角色。然而，随着硬盘容量的增长和技术的进步，MBR 正逐渐被 GPT 分区方案所取代。GPT 分区方案具有更大的磁盘容量支持、更多的分区数量和更高的数据安全性，将成为未来计算机系统分区的主流方案。

#### GPT 分区

GPT（GUID Partition Table）是一种分区表结构，适用于新型磁盘和操作系统。GPT 是 [UEFI](https://uefi.org/)（统一可扩展固件接口）规范的一部分，用于替代传统的 MBR（Master Boot Record）分区表。

**随着计算机技术的发展以及硬盘容量的增长，MBR 分区方案逐渐暴露出容量和分区数量的限制。**为解决这些问题，Intel 在 1999 年引入了 GPT 分区方案。GPT 随后被纳入 UEFI 规范，成为现代计算机系统的主流分区方案。

GPT分区表结构包括以下部分：

1. 保护性MBR（LBA 0）：在 GPT 磁盘的第一个扇区，包含一个伪 MBR，以兼容旧式磁盘管理工具。
2. GPT Header（LBA 1）：包含 GPT 分区表的元数据，如分区表大小、分区表位置等。
3. Partition Entry Array（LBA 2～33）：存储分区条目信息。每个分区条目占用 128 字节，典型的 GPT 分区表支持最多 128 个分区。
4. 备份分区表：GPT 在磁盘的末尾备份了 Header 和 Partition Entry Array，以提高数据安全性。

##### 标准 GPT 结构

| 区域                       | 起始LBA (Hex) | 起始LBA (Oct) | 起始LBA (Dec) | 长度（扇区） | 描述                                       |
| -------------------------- | ------------- | ------------- | ------------- | ------------ | ------------------------------------------ |
| 保护性MBR (Protective MBR) | 0x0           | 00000         | 0             | 1            | 保护性主引导记录，用于兼容旧式磁盘管理工具 |
| GPT Header                 | 0x1           | 00001         | 1             | 1            | 包含GPT分区表的元数据                      |
| Partition Entry Array      | 0x2           | 00002         | 2             | 32           | 存储分区条目信息，每个分区条目占用128字节  |
| 主数据区 (Primary Data)    | 0x22          | 00042         | 34            | 可变         | 磁盘的主要数据存储区域                     |
| 备份Partition Entry Array  | -0x21         | -00041        | -33           | 32           | 磁盘末尾的备份分区条目数组                 |
| 备份GPT Header             | -0x1          | -00001        | -1            | 1            | 磁盘末尾的备份GPT Header                   |

##### 分区条目结构

| 字节偏移 (Hex) | 字节偏移 (Oct) | 字节偏移 (Dec) | 长度 (Byte) | 描述                       |
| -------------- | -------------- | -------------- | ----------- | -------------------------- |
| 0x00           | 000            | 0              | 16          | 分区类型GUID               |
| 0x10           | 020            | 16             | 16          | 唯一分区GUID               |
| 0x20           | 040            | 32             | 8           | 起始LBA地址                |
| 0x28           | 050            | 40             | 8           | 结束LBA地址                |
| 0x30           | 060            | 48             | 8           | 分区属性（如只读、隐藏等） |
| 0x38           | 070            | 56             | 72          | 分区名称（UTF-16LE编码）   |

##### 优点

1. 更大的磁盘容量支持：GPT 支持超过 2TB 的磁盘容量，解决了 MBR 分区方案的容量限制。
2. 更多的分区数量：GPT 支持多达 128 个分区，比 MBR 的分区数量更加灵活。
3. 数据安全性：GPT 具有备份分区表的机制，有助于防止数据丢失。

##### 缺点

1. 兼容性问题：虽然大多数现代操作系统和硬件都支持 GPT，**但在较旧的系统中可能存在兼容性问题。**

GPT 目前适用于以下场景：大容量硬盘（容量大于2TB）、需要创建超过 4 个分区、现代操作系统和硬件（支持UEFI）。

随着计算机技术的发展以及硬盘容量的增长，GPT 分区方案将逐渐成为主流。GPT 在磁盘容量支持、分区数量和数据安全性等方面具有优势，已经成为现代操作系统和硬件的首选分区方案。随着旧式硬件和操作系统的逐渐淘汰，GPT 的普及程度将进一步提高。

未来，GPT 分区方案可能会继续演进，以适应新的技术发展和需求。例如，随着硬盘容量的进一步扩大，GPT 可能需要支持更大的磁盘容量和更多的分区数量。此外，为了提高数据安全性，GPT 可能会引入新的数据保护和恢复机制。

同时，随着新型存储技术（如固态硬盘和非易失性内存）的发展，可能会出现新的分区方案，以满足这些存储设备的特性和性能需求。这些新分区方案可能会与 GPT 并存，甚至在某些场景下取代 GPT。

总之，GPT 分区方案在未来计算机系统中将继续发挥重要作用。随着技术的发展，GPT 可能会不断演进，以适应新的需求和挑战。同时，新型存储技术和分区方案的出现可能会为未来计算机系统带来更多的创新和可能性。

### 分区方案

| 分区       | 建议大小     | 说明                                                         |
| ---------- | ------------ | ------------------------------------------------------------ |
| / (根分区) | > 32GB       | 存放操作系统及程序文件，包括系统配置文件、应用程序及库文件等 |
| swap       | > 2GB        | 虚拟内存，用于内存交换，在物理内存不足时起辅助作用           |
| /home      | 剩余磁盘空间 | 存放用户数据和配置文件，根据个人需求分配磁盘空间             |
| /boot      | < 1GB        | 存放引导程序和内核文件，通常只需较小的磁盘空间               |
| /var       | > 16GB       | 存放系统日志、缓存和其他可变数据                             |
| /tmp       | < 32GB       | 存放临时文件                                                 |

综合考虑以上各分区的建议大小，**总共空间建议至少应 ≥ 128GB，这里的建议数值适用于大多数场景**，但请根据具体需求和磁盘空间进行调整。

### 分区工具

#### parted

Parted（GNU Parted）是一个磁盘分区和管理的命令行工具，它的全称是“GNU Partition Editor”。Parted 是由 GNU 项目开发的自由软件，主要用于创建、修改和删除磁盘分区。它在 Linux 系统中广泛应用，并支持多种文件系统和磁盘标签，如 ext2/ext3/ext4、FAT16/FAT32、NTFS、HFS+、XFS、JFS 等。

Parted 项目始于 1999 年，由 Andrew Clausen 和 Lennert Buytenhek 开发。它的目标是提供一个与商业分区工具如 Partition Magic 类似的功能，但在许可协议方面更自由，同时支持更多的文件系统。随着时间的推移，Parted 不断发展，添加了对更多文件系统和分区表的支持，并在许多 Linux 发行版中成为了默认的磁盘分区工具。

Parted 使用库 libparted 进行磁盘分区操作。libparted 是一个用 C 语言编写的库，提供底层分区表和文件系统的操作。Parted 的命令行界面调用 libparted 的接口，以实现对磁盘分区的管理。这种设计使得其他项目（如图形界面的 GParted）也能利用 libparted 提供的功能。

##### 优点

1. 开源且免费，遵循 GNU GPL 许可协议。
2. 支持多种文件系统和磁盘标签。
3. 支持大容量硬盘和 GPT 分区表。
4. 可以在不损坏数据的情况下调整分区大小。
5. 命令行界面易于编写脚本进行自动化操作。

##### 缺点

1. 对新手来说，命令行界面可能不如图形界面直观。
2. 对某些文件系统的支持可能不如专门针对这些文件系统的工具完善。

##### 常用命令

| 操作                 | 命令示例                                      | 说明                                              |
| -------------------- | --------------------------------------------- | ------------------------------------------------- |
| 查看磁盘信息         | parted /dev/sda print                         | 显示 /dev/sda 的磁盘信息                          |
| 选择磁盘             | parted /dev/sda                               | 操作 /dev/sda 磁盘                                |
| 创建分区表           | parted /dev/sda mklabel gpt                   | 在 /dev/sda 上创建 GPT 分区表                     |
| 创建主分区           | parted /dev/sda mkpart primary ext4 1MiB 2GiB | 创建一个从 1MiB 到 2GiB 的 ext4 主分区            |
| 创建扩展分区         | parted /dev/sda mkpart extended 2GiB 4GiB     | 创建一个从 2GiB 到 4GiB 的扩展分区                |
| 创建逻辑分区         | parted /dev/sda mkpart logical ext4 2GiB 4GiB | 创建一个从 2GiB 到 4GiB 的 ext4 逻辑分区          |
| 删除分区             | parted /dev/sda rm 1                          | 删除编号为 1 的分区                               |
| 改变分区文件系统类型 | parted /dev/sda set 1 ext4 on                 | 将编号为 1 的分区的文件系统类型设置为 ext4        |
| 设置引导标志         | parted /dev/sda set 1 boot on                 | 将编号为 1 的分区设置为引导分区                   |
| 移动分区             | parted /dev/sda move 1 2GiB 4GiB              | 将编号为 1 的分区从当前位置移到 2GiB 到 4GiB 之间 |
| 扩展分区             | parted /dev/sda resizepart 1 4GiB             | 将编号为 1 的分区大小扩展到 4GiB                  |
| 缩小分区             | parted /dev/sda resizepart 1 2GiB             | 将编号为 1 的分区大小缩小到 2GiB                  |
| 激活分区             | parted /dev/sda set 1 lvm on                  | 激活编号为 1 的分区以用于 LVM                     |
| 取消激活分区         | parted /dev/sda set 1 lvm off                 | 取消激活编号为 1 的分区以用于 LVM                 |

Parted 提供了一种免费且开源的磁盘分区管理方案，它解决了在 Linux 系统下对磁盘进行分区操作的需求。此外，它还支持许多文件系统和磁盘标签，从而可以满足不同用户的需求。

Parted 适用于在 Linux 系统下进行磁盘分区管理的场景，包括创建、删除、调整分区大小等操作。**它特别适合那些需要进行批量操作或自动化任务的场景，因为其命令行界面易于编写脚本。**

Parted 将继续保持对新文件系统和磁盘技术的支持，以适应不断发展的硬件和软件环境。此外，开发者可能会继续改进其性能和稳定性，以满足用户在各种场景下的需求。随着技术的发展，Parted 也可能会支持新的存储介质，如固态硬盘、NVMe 等。同时，对于一些现有问题，如对特定文件系统支持的不完善，未来可能会有所改进。另外，随着图形界面工具的普及，Parted 可能会与这些工具更紧密地集成，以提供更友好的用户体验。

#### gdisk

gdisk（GUID Partition Table Disk）是一个用于操作 GPT 分区表的命令行工具。它与传统的 fdisk 工具类似，但是专门针对 GPT 分区表进行了优化。gdisk 是由 Rod Smith 开发的，随着大容量硬盘的普及以及对 UEFI（统一可扩展固件接口）支持的增加，GPT 分区表成为了越来越重要的一部分。

gdisk 的开发始于 2009 年，因为那时 MBR 分区表无法满足对大容量硬盘的需求。目前随着时间的推移，gdisk 支持了越来越多的功能，使其成为了处理 GPT 分区表的重要工具。

gdisk 基于 libparted 库通过调用底层库函数来读取、修改、写入 GPT 分区表信息。这使得它能够在不同的平台上运行。

gdisk 支持 GPT 分区表，解决了 MBR 分区表的闲置，支持 UEFI 引导方式，并且拥有与 fdisk 类似的命令行界面，便于用户上手。gdisk 专门针对 GPT 分区表，所以并不能直接处理 MBR 分区表。

##### 常用命令

| 命令  | 选项 | 描述                                                         |
| ----- | ---- | ------------------------------------------------------------ |
| gdisk |      | 启动 gdisk，需要指定磁盘设备作为参数，如：`gdisk /dev/sda`   |
|       | ?    | 显示帮助信息，列出所有可用命令                               |
|       | p    | 显示分区表信息                                               |
|       | n    | 新建分区，会提示输入分区号、起始扇区和结束扇区等信息         |
|       | d    | 删除分区，会提示输入分区号                                   |
|       | i    | 显示分区详细信息，会提示输入分区号                           |
|       | r    | 进入恢复和转换模式，用于 MBR 与 GPT 之间的转换和其他高级功能 |
|       | t    | 更改分区类型，会提示输入分区号和新的分区类型代号             |
|       | c    | 更改分区名称，会提示输入分区号和新的分区名称                 |
|       | s    | 对分区表排序，根据分区起始位置重新排列分区号                 |
|       | v    | 验证分区表，检查是否存在问题                                 |
|       | x    | 进入专家模式，提供额外的高级命令                             |
|       | w    | 保存更改，将修改写入磁盘，会提示是否确认                     |
|       | q    | 退出 gdisk，不保存修改                                       |

#### fdisk

fdisk 是一个 Linux 系统下的磁盘分区管理工具。它可以用于创建、删除、修改分区表，以及设置分区启动标志。fdisk 支持 MBR（主引导记录）分区表，适用于 BIOS 分区表管理。

fdisk 最早出现在 Unix 系统中，随着时间的推移，它被移植到了 Linux 平台。在 Linux 中，fdisk 成为了一个非常受欢迎的分区管理工具。随着 GPT 分区表的出现和逐渐普及，fdisk 工具的替代品 gdisk 也应运而生。

fdisk 通过读取磁盘的主引导记录（MBR）获取分区信息。MBR 位于磁盘的第一个扇区，包含了分区表和启动程序。fdisk 使用用户提供的命令对分区表进行修改，并将更改写回磁盘。

fdisk 虽然简单易用，功能全面，但是支支持 MBR 分区表，无法处理 GPT 分区表；fdisk 更适用于需要管理 MBR 分区表的系统。随着 GPT 分区表和 UEFI 引导方式的普及，MBR 分区表和传统 BIOS 引导逐渐被淘汰。

## 磁盘管理

磁盘管理是计算机系统管理的重要部分，涉及到磁盘的格式化、检查、修复、清理、优化、监控和诊断等操作。在Linux 系统中，有许多命令行工具可以帮助我们完成这些任务。

### 磁盘格式化

磁盘格式化主要是将磁盘分区初始化为特定的文件系统，以便操作系统能够读写数据。

常用的磁盘格式化工具有：

- mkfs：通用的文件系统格式化工具，支持多种文件系统。
- mke2fs：专门用于创建ext2、ext3、ext4文件系统的工具。

常用命令及选项：

| 命令                     | 说明                                                        |
| ------------------------ | ----------------------------------------------------------- |
| mkfs -t ext4 /dev/sda1   | 将/dev/sda1分区格式化为ext4文件系统                         |
| mke2fs -j /dev/sda1      | 将/dev/sda1分区格式化为ext3文件系统（带日志功能）           |
| mke2fs -b 4096 /dev/sda1 | 将/dev/sda1分区格式化为ext2文件系统，并设置块大小为4096字节 |

### 磁盘检查与修复

磁盘检查与修复主要是检查文件系统的完整性、查找并修复磁盘错误。

常用的磁盘检查与修复工具有：

- 文件系统检查：fsck、e2fsck（针对ext2、ext3、ext4）
- 坏扇区检测：badblocks
- 数据恢复：testdisk、photorec
- 文件系统修复：xfs_repair（针对xfs）、btrfs-check（针对btrfs）

常用命令及选项：

| 命令                           | 说明                                                    |
| ------------------------------ | ------------------------------------------------------- |
| fsck /dev/sda1                 | 检查并尝试修复/dev/sda1分区的文件系统                   |
| e2fsck -f /dev/sda1            | 强制检查并尝试修复/dev/sda1分区的ext2/ext3/ext4文件系统 |
| badblocks -v /dev/sda1         | 以详细模式检查/dev/sda1分区的坏扇区                     |
| testdisk /dev/sda              | 检查并尝试恢复/dev/sda磁盘上的分区表、引导扇区等        |
| photorec /dev/sda1             | 从/dev/sda1分区中恢复丢失的文件                         |
| xfs_repair /dev/sda1           | 检查并修复/dev/sda1分区的xfs文件系统                    |
| btrfs-check --repair /dev/sda1 | 检查并修复/dev/sda1分区的btrfs文件系统                  |

### 磁盘清理与优化

磁盘清理与优化主要是清除无用的临时文件、整理碎片、压缩磁盘空间以及加密磁盘等操作，以提高磁盘的使用效率和安全性。

常用的磁盘清理与优化工具有：

- 清理临时文件：tmpwatch、systemd-tmpfiles
- 碎片整理：e2fsck（针对ext系列）、xfs_fsr（针对xfs）
- 磁盘压缩：btrfs filesystem defragment（针对btrfs）
- 磁盘加密：dm-crypt、LUKS、eCryptfs、VeraCrypt等

常用命令及选项：

| 命令                                   | 说明                                                 |
| -------------------------------------- | ---------------------------------------------------- |
| tmpwatch --mtime 7 /tmp                | 删除/tmp目录中超过7天未修改的临时文件                |
| systemd-tmpfiles --clean               | 按照/tmpfiles.d/目录中的配置文件，清理过期的临时文件 |
| e2fsck -D /dev/sda1                    | 对/dev/sda1分区的ext2/ext3/ext4文件系统进行碎片整理  |
| xfs_fsr /dev/sda1                      | 对/dev/sda1分区的xfs文件系统进行碎片整理             |
| btrfs filesystem defragment /mnt/btrfs | 对挂载在/mnt/btrfs的btrfs文件系统进行压缩整理        |
| cryptsetup luksFormat /dev/sda1        | 使用LUKS对/dev/sda1分区进行加密                      |
| veracrypt --create /dev/sda1           | 使用VeraCrypt对/dev/sda1分区进行加密                 |

### 磁盘监控与诊断

磁盘清理与优化主要是清除无用的临时文件、整理碎片、压缩磁盘空间以及加密磁盘等操作，以提高磁盘的使用效率和安全性。

常用的磁盘清理与优化工具有：

- 清理临时文件：tmpwatch、systemd-tmpfiles
- 碎片整理：e2fsck（针对ext系列）、xfs_fsr（针对xfs）
- 磁盘压缩：btrfs filesystem defragment（针对btrfs）
- 磁盘加密：dm-crypt、LUKS、eCryptfs、VeraCrypt等

常用命令及选项：

| 命令                                   | 说明                                                 |
| -------------------------------------- | ---------------------------------------------------- |
| tmpwatch --mtime 7 /tmp                | 删除/tmp目录中超过7天未修改的临时文件                |
| systemd-tmpfiles --clean               | 按照/tmpfiles.d/目录中的配置文件，清理过期的临时文件 |
| e2fsck -D /dev/sda1                    | 对/dev/sda1分区的ext2/ext3/ext4文件系统进行碎片整理  |
| xfs_fsr /dev/sda1                      | 对/dev/sda1分区的xfs文件系统进行碎片整理             |
| btrfs filesystem defragment /mnt/btrfs | 对挂载在/mnt/btrfs的btrfs文件系统进行压缩整理        |
| cryptsetup luksFormat /dev/sda1        | 使用LUKS对/dev/sda1分区进行加密                      |
| veracrypt --create /dev/sda1           | 使用VeraCrypt对/dev/sda1分区进行加密                 |
| fio --name=test --rw=read --bs=4k --numjobs=4 --size=1G --runtime=60s --ioengine=libaio --iodepth=32 --time_based | 测试磁盘的I/O性能，以4K块大小、深度为32的顺序读取方式运行60秒的测试 |
| iozone -a -s 1G | 使用iozone工具对1GB文件进行自动性能测试 |
| df -h | 以人类可读的格式显示磁盘空间使用情况 |
| du -sh /home | 显示/home目录的磁盘空间占用情况 |
| ncdu /home | 以图形界面显示/home目录的磁盘空间占用情况 |
| iostat -xz 5 | 每隔5秒输出一次磁盘I/O统计信息 |
| iotop -o | 实时显示当前磁盘I/O活动的进程，只显示有I/O操作的进程 |

## 备份恢复

备份恢复是计算机系统管理的重要部分，涉及到数据的备份、存储和恢复等操作。通过合理的备份策略和方式，可以确保系统的稳定性和数据的安全。

### 备份策略

备份策略是指备份数据的范围和周期。常见的备份策略：

| 备份策略     | 优点                                                         | 缺点                                                         | 适用场景                                                     |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 完整备份     | 可以完整地备份所有数据，恢复时速度快                         | 备份时间长，备份数据量大，占用存储空间大                     | 数据量较小、备份频率较低、对数据完整性要求较高的场景         |
| 增量备份     | 备份时间短，占用存储空间小，可以快速备份所有修改的数据       | 恢复速度慢，需要还原完整的备份链，备份链中任意一次备份失败，后续备份将无法进行 | 大量数据需要备份，数据变化较频繁的场景                       |
| 差异备份     | 备份数据量小，备份速度快，恢复速度快                         | 恢复速度慢，需要还原完整的备份链，备份链中任意一次备份失败，后续备份将无法进行 | 备份频率较高，数据变化较频繁，但备份数据量不宜过大的场景     |
| 定期备份     | 定期备份可以保证备份数据的实时性和完整性                     | 需要人工干预备份，可能会漏备                                 | 数据量较大、需要保证数据实时性和完整性的场景                 |
| 混合备份策略 | 可以充分利用完整备份、增量备份和差异备份各自的优点，灵活备份 | 实现较为复杂，管理备份链需要一定的技术水平，备份数据量大     | 数据量较大、备份频率较高、需要保证备份数据完整性和实时性的场景 |

**备份策略的选择应该根据实际的业务需求和场景来确定。**例如，对于一个数据量较小、备份频率较低、对数据完整性要求较高的场景，完整备份可能是更好的选择，但如果数据变化较频繁，备份数据量较大，增量备份或差异备份可能是更好的选择。在实际应用中，也可以根据不同的数据类型和备份需求，结合多种备份策略进行混合备份，以达到更好的备份效果。

### 备份方式

备份方式是指备份的数据类型和范围。常见的备份方式：

| 备份类型 | 概念                               | 优点                                           | 缺点                                               | 适用场景                                                   |
| -------- | ---------------------------------- | ---------------------------------------------- | -------------------------------------------------- | ---------------------------------------------------------- |
| 系统备份 | 对整个操作系统进行备份             | 备份恢复速度快，可快速恢复整个系统             | 需要重启系统才能恢复，需要专业技术人员进行操作     | 升级系统、修复系统、系统迁移、系统备份恢复                 |
| 数据备份 | 对重要数据进行备份                 | 备份恢复速度快，只恢复需要的数据，节省存储空间 | 无法恢复系统设置，不适用于系统级别的恢复           | 备份重要数据、恢复文件和数据                               |
| 分区备份 | 对磁盘分区进行备份                 | 可以备份恢复单独的分区                         | 无法恢复其他分区的数据，恢复速度慢                 | 对某个分区进行备份、对分区进行数据恢复                     |
| 磁盘备份 | 对整个硬盘进行备份，包括系统和数据 | 备份恢复速度快，可快速恢复整个系统             | 需要专业技术人员进行操作，恢复速度慢，备份数据量大 | 硬盘更换、系统崩溃、病毒攻击、数据丢失等紧急情况的备份恢复 |

**不同类型的备份应该根据实际的业务需求和场景来选择。**例如，对于需要备份整个系统的情况，系统备份可能是最好的选择；对于只需要备份重要数据的情况，数据备份可能是更好的选择；对于需要备份整个硬盘的情况，磁盘备份可能是最好的选择。在实际应用中，也可以结合多种备份方式进行备份，以达到更好的备份效果。

### 备份工具

备份工具是用于执行备份任务的软件。常见的备份工具有：

- 文件级别备份：rsync、tar、cpio、duplicity 等
- 块级别备份：dd、partclone、Clonezilla 等
- 数据库备份：mysqldump、pg_dump、oracle-exp 等

常用命令及选项：

| 命令                                         | 说明                                                         |
| -------------------------------------------- | ------------------------------------------------------------ |
| rsync -avz /src/ /dst/                       | 使用rsync工具将/src/目录下的文件同步到/dst/目录下            |
| tar czf backup.tar.gz /src/                  | 使用tar工具将/src/目录下的文件打包成backup.tar.gz文件        |
| cpio -o > backup.cpio < filelist.txt         | 使用cpio工具将filelist.txt中的文件打包成backup.cpio文件      |
| duplicity /src/ file:///dst/                 | 使用duplicity工具将/src/目录下的文件加密并备份到/dst/目录下  |
| dd if=/dev/sda1 of=backup.img                | 使用dd工具备份/dev/sda1分区到backup.img文件                  |
| partclone.ext4 -c -s /dev/sda1 -o backup.img | 使用partclone工具备份ext4格式的/dev/sda1分区到backup.img文件 |
| mysqldump -u user -p dbname > backup.sql     | 使用mysqldump工具备份MySQL数据库到backup.sql文件             |
| pg_dump -U user dbname > backup.sql          | 使用pg_dump工具备份PostgreSQL数据库到backup.sql文件          |

### 恢复操作

恢复操作是指根据备份数据恢复系统或数据的过程。常见的恢复操作有：

- 系统还原：使用系统备份恢复操作系统、配置文件、应用程序等
- 数据恢复：从数据备份中恢复用户数据、数据库等
- 磁盘恢复：使用磁盘备份恢复整个磁盘及其上的所有分区
- 备份恢复策略：根据备份策略选择合适的恢复方法和顺序

常用命令及选项：

| 命令                                         | 说明                                                         |
| -------------------------------------------- | ------------------------------------------------------------ |
| rsync -avz /src/ /dst/                       | 使用rsync工具从/src/目录下恢复文件到/dst/目录下              |
| tar xzf backup.tar.gz -C /dst/               | 使用tar工具从backup.tar.gz文件恢复文件到/dst/目录下          |
| cpio -i < backup.cpio                        | 使用cpio工具从backup.cpio文件恢复文件                        |
| duplicity restore file:///src/ /dst/         | 使用duplicity工具从/src/目录下的加密备份恢复文件到/dst/目录下 |
| dd if=backup.img of=/dev/sda1                | 使用dd工具从backup.img文件恢复/dev/sda1分区                  |
| partclone.ext4 -r -s backup.img -o /dev/sda1 | 使用partclone工具从backup.img文件恢复ext4格式的/dev/sda1分区 |
| mysql -u user -p dbname < backup.sql         | 使用mysql命令恢复MySQL数据库从backup.sql文件                 |
| psql -U user dbname < backup.sql             | 使用psql命令恢复PostgreSQL数据库从backup.sql文件             |

## 高级特性

### 磁盘阵列

#### RAID 0（条带化）

![RAID 0](https://static.7wate.com/img/2023/04/21/14427cb4c5bfe.png)

RAID 0（条带化）是一种数据分发方式，数据被分成大小相等的块并分别存储在多个硬盘上，以提高读写性能。它没有冗余机制，一旦任意一块硬盘出现故障，整个阵列的数据都会丢失。

#### RAID 1（镜像）

![RAID 1](https://static.7wate.com/img/2023/04/21/51b7d32f3ef4f.png)

RAID 1（镜像）是通过在多个硬盘上保存完全相同的数据来提高数据可靠性。每个硬盘上的数据都是相同的，如果一个硬盘出现故障，数据仍然可以从其他硬盘中恢复。

#### RAID 5（分布式奇偶校验）

![RAID 5](https://static.7wate.com/img/2023/04/21/46b8ef22d0f89.png)

RAID 5（分布式奇偶校验）将数据块和校验块分别存储在多个硬盘上。校验块被计算为所有数据块的异或值，以提供数据冗余和容错能力。RAID 5可以通过使用奇偶校验的方式在一个硬盘故障时恢复数据，但是如果两个硬盘故障，则可能会导致数据无法恢复。

#### RAID 6（双奇偶校验）

![RAID 6](https://static.7wate.com/img/2023/04/21/3b1de1acc0ada.png)

RAID 6（双奇偶校验）与RAID 5类似，但是它使用两个校验块来提供更高的数据冗余和容错能力，可以在两个硬盘故障的情况下恢复数据。

#### RAID 10/01（镜像+条带化）

![RAID 1+0](https://static.7wate.com/img/2023/04/21/8226c8415d5ab.png)

![RAID 0+1](https://static.7wate.com/img/2023/04/21/b0cc485a28a53.png)

RAID 10/01（镜像+条带化）都是将 RAID 0 和 RAID 1 组合而成的RAID级别，其中 RAID 10 是镜像+条带化，RAID 01 是条带化+镜像。它们的区别在于数据的条带化和镜像是先进行哪一个操作。

- RAID 10：镜像+条带化 RAID 10 首先将多个磁盘分成两组，每一组中的磁盘都是相互镜像的，然后将这两组磁盘进行条带化。
- RAID 01：条带化+镜像 RAID 01 首先将多个磁盘进行条带化，然后将这些条带进行镜像备份。

RAID 10 和 RAID 01 虽然都是将 RAID 0 和 RAID 1 进行组合，但它们的性能和可靠性并不相同。RAID 10 通常被认为比 RAID 01 更为可靠，因为它允许多个磁盘同时出现故障而不会导致数据丢失。另外，RAID 10 的写入性能也比 RAID 01 更好，因为 RAID 10 能够同时使用多个磁盘进行并行写入。

#### RAID 级别对比

| RAID级别 | 优点                                                   | 缺点                                       | 适用场景                                                     |
| -------- | ------------------------------------------------------ | ------------------------------------------ | ------------------------------------------------------------ |
| RAID 0   | 高性能，读写速度快，性价比高                           | 容错性差，一块硬盘出问题会导致全部数据丢失 | 需要高性能的应用场景，如视频编辑、大型数据库等               |
| RAID 1   | 数据冗余，可靠性高，单盘故障不会影响数据               | 容量利用率低，需要成倍增加硬盘数量         | 对数据可靠性要求较高的应用场景，如企业数据中心等             |
| RAID 5   | 较高的读写性能，具有数据冗余，单盘故障仍能正常运行     | 写性能较差，阵列重建需要消耗大量时间       | 对读写性能和数据可靠性要求较高的应用场景，如小型企业数据库等 |
| RAID 6   | 可以容忍任意两块硬盘故障，可靠性更高                   | 读写性能较差，阵列重建需要更长时间         | 对数据可靠性要求非常高的应用场景，如金融、医疗等             |
| RAID 10  | 读写性能优秀，可靠性高，同时具备数据冗余和高性能的优点 | 成本较高，容量利用率低                     | 对读写性能和数据可靠性要求都很高的应用场景，如大型企业数据库等 |

**RAID 级别的选择应该根据实际的业务需求和场景来确定。**例如，对于一个需要高性能和可靠性的应用场景，RAID 10 可能是更好的选择，但如果成本和容量利用率是更重要的考虑因素，RAID 5 可能是更好的选择。

### LVM

逻辑卷管理（Logical Volume Management，LVM）是一种在 Linux 系统中管理硬盘空间的技术。它允许将多个硬盘分区或物理硬盘组合成一个逻辑卷，从而更加灵活地管理存储空间。LVM 允许管理员在不重启系统的情况下调整磁盘空间分配，提供了一些高级的存储管理功能，如快照、镜像和跨磁盘分区等。LVM 通常被用于服务器环境中，因为它可以有效地处理大容量存储设备。

LVM 最初是由 Sistina Software 公司于 1998 年开发的，旨在提供一种动态分区管理技术，以替代传统的静态分区方式。在 2001 年，Red Hat 收购了 Sistina Software 公司，将 LVM 整合到 Red Hat Enterprise Linux 中，并在 2002 年的 Linux 内核 2.4.0 版本中首次亮相。此后，LVM 逐渐成为了 Linux 系统中的标准组件之一，并且得到了广泛的应用。

LVM的实现原理是将物理存储设备（如磁盘、分区）分为若干个物理卷（PV），并将多个物理卷组成一个卷组（VG）。然后在卷组上创建一个或多个逻辑卷（LV），并将逻辑卷格式化为文件系统。当需要增加存储空间时，可以将一个或多个物理卷添加到卷组中，并将空间分配给逻辑卷。当需要缩小存储空间时，可以将逻辑卷缩小，并将空闲空间返回给卷组。

![LVM 构成](https://static.7wate.com/img/2023/04/21/2d92995f6ad28.png)

LVM 由以下三个主要组件组成：

1. 物理卷（Physical Volume，PV）：物理卷是指磁盘或分区等物理存储设备。在使用 LVM 之前，需要将物理存储设备划分为物理卷，并且将它们标记为 LVM 可用的卷。
2. 卷组（Volume Group，VG）：卷组是由一个或多个物理卷组成的逻辑容器。卷组可以包含多个物理卷，这些物理卷可以来自不同的磁盘，也可以是同一磁盘上的不同分区。在 LVM 中，卷组是用来为逻辑卷提供空间的。
3. 逻辑卷（Logical Volume，LV）：逻辑卷是在卷组上创建的逻辑分区。逻辑卷可以动态地分配和释放存储空间，并且可以根据需要调整大小。逻辑卷可以被格式化为文件系统，并像常规分区一样使用。

#### 优点

1. 动态分区调整：LVM可以在不重启系统的情况下动态地调整逻辑卷的大小，这意味着可以在运行时增加或减少逻辑卷的大小，而不需要对系统进行重启。
2. 快照功能：LVM提供了快照功能，可以在不影响正在运行的系统的情况下创建逻辑卷的快照。这使得系统管理员可以在进行一些重要操作之前，为系统创建一个快照，以便在出现问题时可以回滚。
3. 跨磁盘分区：LVM可以跨越多个物理卷创建逻辑卷，这使得可以将逻辑卷分配到多个磁盘上，提高了系统的可靠性和可用性。

#### 缺点

1. 额外的管理和学习成本：使用LVM需要学习额外的命令和管理技术，这会增加管理员的管理和学习成本。
2. 性能损失：LVM在数据存储和检索时会引入一定的性能损失，这主要是因为需要对数据进行多次转换。

LVM 通常用于服务器环境中，因为它可以有效地处理大容量存储设备。特别是在云计算环境下，LVM 的优点更加明显，因为它可以动态地分配和管理存储空间。在虚拟化环境下，LVM 可以在多个虚拟机之间共享存储，并根据需要动态分配存储容量。此外，LVM 还支持快照功能，可以在不影响正在运行的系统的情况下创建逻辑卷的快照，这使得系统管理员可以在进行一些重要操作之前，为系统创建一个快照，以便在出现问题时可以回滚。

LVM 未来的发展方向包括高效性能、智能化管理、安全的数据存储和灵活的可扩展性。未来 LVM 将需要更快的存储和数据传输速度、自动化管理功能、更加严格的数据保护和隔离机制、以及支持更多存储设备类型。

#### 命令

| 命令        | 常用选项               | 示例                                         | 释义               |
| ----------- | ---------------------- | -------------------------------------------- | ------------------ |
| `pvcreate`  | `-v`、`-f`、`-M2`      | `pvcreate /dev/sdb1`                         | 创建物理卷         |
| `vgcreate`  | `-v`、`-f`、`-M2`      | `vgcreate vg1 /dev/sdb1`                     | 创建卷组           |
| `lvcreate`  | `-v`、`-L`、`-n`、`-i` | `lvcreate -L 10G -n lv1 vg1`                 | 创建逻辑卷         |
| `lvextend`  | `-L`、`-r`             | `lvextend -L +5G /dev/vg1/lv1`               | 扩展逻辑卷的大小   |
| `lvreduce`  | `-L`、`-r`             | `lvreduce -L -3G /dev/vg1/lv1`               | 减小逻辑卷的大小   |
| `pvdisplay` | `-v`、`-m`             | `pvdisplay /dev/sdb1`                        | 显示物理卷的信息   |
| `vgdisplay` | `-v`、`-m`             | `vgdisplay vg1`                              | 显示卷组的信息     |
| `lvdisplay` | `-v`、`-m`             | `lvdisplay /dev/vg1/lv1`                     | 显示逻辑卷的信息   |
| `pvmove`    | `-v`、`-n`             | `pvmove /dev/sda1 /dev/sdb1`                 | 移动物理卷上的数据 |
| `vgextend`  | `-v`、`-a`             | `vgextend vg1 /dev/sdc1`                     | 将物理卷加入卷组   |
| `vgreduce`  | `-v`、`-a`             | `vgreduce vg1 /dev/sdb1`                     | 从卷组中移除物理卷 |
| `lvrename`  | `-v`、`-L`             | `lvrename /dev/vg1/oldname /dev/vg1/newname` | 重命名逻辑卷       |

#### 选项

| 选项/全拼                 | 释义                                   |
| ------------------------- | -------------------------------------- |
| `-v, --verbose`           | 显示详细的信息                         |
| `-f, --force`             | 强制执行操作                           |
| `-M2, --metadatacopies 2` | 设置元数据区域的备份级别               |
| `-L, --size`              | 指定逻辑卷的大小                       |
| `-n, --name`              | 指定逻辑卷的名称                       |
| `-i, --stripes`           | 指定逻辑卷的副本数                     |
| `-r, --resizefs`          | 在逻辑卷大小改变后自动执行文件系统调整 |
| `-m, --maps`              | 显示逻辑卷的映射信息                   |
| `-a, --all`               | 将所有未使用的物理卷都添加到卷组中     |

#### 实例

```mermaid
graph LR;
    A[创建物理卷 PV] --> B[创建卷组 VG ];
    B --> C[创建逻辑卷 LV ];
    C --> D[格式化文件系统];
    D --> E[挂载文件系统];
    E --> F[使用文件系统];
    
```

1. ##### 创建物理卷(PV)

在实际操作中，我们需要首先查看系统中有哪些可用的物理卷，使用命令`lsblk`可以列出所有的物理磁盘及其分区信息。然后使用`pvcreate`命令将指定的物理卷初始化为 LVM 物理卷，例如：

```shell
[root@rhel ~]# lsblk
NAME          MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
nvme0n1       259:0    0   64G  0 disk
├─nvme0n1p1   259:1    0    1G  0 part /boot
└─nvme0n1p2   259:2    0   63G  0 part
  ├─rhel-root 253:0    0 39.7G  0 lvm  /
  ├─rhel-swap 253:1    0  3.9G  0 lvm  [SWAP]
  └─rhel-home 253:2    0 19.4G  0 lvm  /home
nvme0n2       259:3    0    8G  0 disk
nvme0n3       259:4    0    8G  0 disk
[root@rhel ~]# pvcreate /dev/nvme0n2 
  Physical volume "/dev/nvme0n2" successfully created.
[root@rhel ~]# pvcreate /dev/nvme0n3
  Physical volume "/dev/nvme0n3" successfully created.
```

2. ##### 创建卷组(VG)

在物理卷初始化之后，我们需要将其添加到一个卷组中。使用`vgcreate`命令可以创建一个新的卷组，并将一个或多个物理卷添加到其中，例如：

```shell
[root@rhel ~]# vgcreate data_nvme_vg /dev/nvme0n2 /dev/nvme0n3
  Volume group "data_nvme_vg" successfully created
[root@rhel ~]# vgdisplay data_nvme_vg
  --- Volume group ---
  VG Name               data_nvme_vg
  System ID
  Format                lvm2
  Metadata Areas        2
  Metadata Sequence No  1
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                0
  Open LV               0
  Max PV                0
  Cur PV                2
  Act PV                2
  VG Size               15.99 GiB
  PE Size               4.00 MiB
  Total PE              4094
  Alloc PE / Size       0 / 0
  Free  PE / Size       4094 / 15.99 GiB
  VG UUID               MbZpcX-1H5P-RKBU-aEAM-9AE3-ums0-nQ2zVc
```

3. ##### 创建逻辑卷(LV)

在卷组创建之后，我们可以使用`lvcreate`命令创建一个或多个逻辑卷，并指定它们的大小、名称、副本数等信息，例如：

```shell
[root@rhel ~]# lvcreate -L 8G -n data_nvme_lv1 data_nvme_vg
  Logical volume "data_nvme_lv1" created.
[root@rhel ~]# lvdisplay /dev/data_nvme_vg/data_nvme_lv1
  --- Logical volume ---
  LV Path                /dev/data_nvme_vg/data_nvme_lv1
  LV Name                data_nvme_lv1
  VG Name                data_nvme_vg
  LV UUID                YFSoPg-xCQu-EFLB-lqUC-o7u5-5bhS-N6LJRT
  LV Write Access        read/write
  LV Creation host, time rhel, 2023-04-24 10:23:20 +0800
  LV Status              available
  # open                 0
  LV Size                8.00 GiB
  Current LE             2048
  Segments               2
  Allocation             inherit
  Read ahead sectors     auto
  - currently set to     8192
  Block device           253:3
```

4. ##### 格式化文件系统

在逻辑卷创建之后，我们需要格式化其文件系统以便进行挂载和使用。使用`mkfs`命令可以对逻辑卷上的文件系统进行格式化，例如：

```shell
[root@rhel ~]# mkfs.ext4 /dev/data_nvme_vg/data_nvme_lv1
mke2fs 1.46.5 (30-Dec-2021)
创建含有 2097152 个块（每块 4k）和 524288 个inode的文件系统
文件系统UUID：68dd2677-4f0e-421f-bf14-9216eb34b3e5
超级块的备份存储于下列块：
        32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632

正在分配组表： 完成
正在写入inode表： 完成
创建日志（16384 个块）完成
写入超级块和文件系统账户统计信息： 已完成
```

5. ##### 挂载文件系统

在格式化文件系统之后，我们需要将其挂载到系统中的一个目录中，以便进行使用。使用`mount`命令可以将格式化后的文件系统挂载到指定的目录中，例如：

```shell
[root@rhel ~]# mkdir /mnt/data_nvme_lv1
[root@rhel ~]# mount /dev/data_nvme_vg/data_nvme_lv1 /mnt/data_nvme_lv1/
```

6. ##### 使用文件系统

最后，我们可以在挂载的文件系统上进行文件的读写和访问等操作，例如：

```shell
[root@rhel ~]# cd /mnt/data_nvme_lv1/
[root@rhel data_nvme_lv1]# ll
总用量 16
drwx------. 2 root root 16384  4月 24 10:25 lost+found
[root@rhel data_nvme_lv1]# echo "hello world!" >> demo.txt
[root@rhel data_nvme_lv1]# cat demo.txt
hello world!
```

7. ##### 调整逻辑卷容量大小

如果想调整 lv 逻辑卷的容量大小可以使用`lvextend`、`resize2fs`，例如为 `/dev/data_nvme_vg/data_nvme_lv1` 增加 2GB 容量。

```shell
[root@rhel data_nvme_lv1]# lvextend -L +2G /dev/data_nvme_vg/data_nvme_lv1
  Size of logical volume data_nvme_vg/data_nvme_lv1 changed from 8.00 GiB (2048 extents) to 10.00 GiB (2560 extents).
  Logical volume data_nvme_vg/data_nvme_lv1 successfully resized.
[root@rhel data_nvme_lv1]# resize2fs /dev/data_nvme_vg/data_nvme_lv1
resize2fs 1.46.5 (30-Dec-2021)
/dev/data_nvme_vg/data_nvme_lv1 上的文件系统已被挂载于 /mnt/data_nvme_lv1；需要进行在线调整大小

old_desc_blocks = 1, new_desc_blocks = 2
/dev/data_nvme_vg/data_nvme_lv1 上的文件系统现在为 2621440 个块（每块 4k）。

[root@rhel data_nvme_lv1]# df -h /dev/data_nvme_vg/data_nvme_lv1
文件系统                                容量  已用  可用 已用% 挂载点
/dev/mapper/data_nvme_vg-data_nvme_lv1  9.8G   28K  9.3G    1% /mnt/data_nvme_lv1
```

### 其他

#### 网络文件系统

网络文件系统（如 NFS、Samba）允许不同操作系统的计算机在网络上共享文件和目录。这使得跨平台文件共享变得简单，提高了团队协作效率。NFS 主要用于 UNIX/Linux 系统间的文件共享，而 Samba 则提供了在 Windows 和 UNIX/Linux 系统间共享文件的能力。

#### iSCSI

iSCSI（Internet Small Computer System Interface）是一种网络存储技术，允许将存储设备（如磁盘阵列）共享给其他计算机。通过 iSCSI，计算机可以通过网络访问共享的存储设备，就像直接连接到本地硬盘一样。这大大简化了存储管理，并提高了存储资源的利用率。

#### RAID透传

RAID 透传是一种将物理 RAID 卡的功能直接传递给虚拟机的技术。通过 PCIe 直通，虚拟机可以直接访问 RAID 卡，从而获得更好的存储性能和可靠性。这种方法允许虚拟机完全利用 RAID 卡的性能和冗余功能，提高数据保护和虚拟机性能。

#### 存储池

存储池是一种将多个物理磁盘组合成一个逻辑存储单元的技术。一些现代文件系统（如 ZFS、Btrfs）支持存储池功能，允许管理员轻松地添加、删除或替换磁盘，以满足存储需求。存储池提供了数据冗余、快照、自动修复等高级功能，确保数据的可靠性和完整性。

#### 分布式存储

分布式存储系统（如Ceph、GlusterFS）是一种将数据分散在多个存储节点上的技术，实现高可用、高扩展性的存储方案。分布式存储系统通常采用数据副本、纠删码等技术保证数据的可靠性，当部分存储节点发生故障时，系统仍然可以继续提供服务。此外，分布式存储系统具有良好的横向扩展性，可以通过添加更多节点来扩展存储容量和性能。
