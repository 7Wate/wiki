---
id: 函数方法
title: 函数方法
sidebar_position: 5
data: 2022年2月10日
---

## 函数

通过白盒/黑盒封装多行代码的实现，一般情况下拥有输入和输出，用来**简化代码**、**重复调用**和**模块化编程**。

在 Python 中可以使用`def`关键字来定义函数，和变量一样每个函数也有一个响亮的名字，而且命名规则跟变量的命名规则是一致的。函数内的第一条语句是字符串时，该字符串就是**文档字符串**，也称为 docstring。

![img](https://static.7wate.com/img/2022/11/20/10cf11ddd3b18.png)

```python
# 语法
def 函数名（参数列表）:
    函数体
    
# 实例
def fib(n): 
    """输出限定数值内的斐波那契数列函数"""
    a, b = 0, 1
    while a < n:
        print(a, end=' ')
        a, b = b, a+b
    print()
```

### 参数传递

python 中类型属于对象，对象有不同类型的区分，变量是没有类型的。**python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象**。

#### 可更改与不可更改对象

在 python 中 strings,、tuples 和 numbers 是不可更改的对象，而 list、dict 等则是可以修改的对象。

- **不可变类型：**变量赋值 **a=5** 后再赋值 **a=10**，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变 a 的值，相当于新生成了 a。
- **可变类型：**变量赋值 **la=[1,2,3,4]** 后再赋值 **la[2]=5** 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。

#### 参数传递

- **不可变类型：**类似 C++ 的值传递，如整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a) 内部修改 a 的值，则是新生成一个 a 的对象。
- **可变类型：**类似 C++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响

### 默认值参数

在 Python 中，函数的参数可以有默认值，也支持使用可变参数，所以 Python 并不需要像其他语言一样支持函数的重载，因为我们在定义一个函数的时候可以让它有多种不同的使用方式。

```python
def add(a=0, b=0, c=0):
    """三个数相加"""
    return a + b + c
add(1,2)
# 3
```

### 键值参数

`kwarg=value` 形式的 关键字参数 也可以用于调用函数。函数示例如下：

该函数接受一个必选参数（`voltage`）和三个可选参数（`state`, `action` 和 `type`）。

```python
def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):
    print("-- This parrot wouldn't", action, end=' ')
    print("if you put", voltage, "volts through it.")
    print("-- Lovely plumage, the", type)
    print("-- It's", state, "!")

parrot("halo",type="test")

# -- This parrot wouldn't voom if you put halo volts through it.
# -- Lovely plumage, the test
# -- It's a stiff !
```

### 特殊参数

#### 可变参数 *

在参数名前面的 * 表示 args 是一个可变参数，可以输入多个参数。

```python
def add2(*args):
    total = 0
    for val in args:
        total += val
    print(total)

add2(1,2,3)
# 6
```

#### 键值参数 **

在参数名前面的 ** 表示 args 是一个可变参数，可以输入键值对。

```python
def add2(**arg):
    print(arg)

add2(name="halo")
# {'name': 'halo'}
```

#### 限位置参数 /

`/`必须放在形参后面表示限制位置参数，实参必须按照形参位置输入。

```python
def pos_only_arg(arg, /):
    print(arg)
```

#### 限关键字参数 *

`*`必须放在形参前面表示限关键字参数，实参必须按键值参数输入。

```python
def kwd_only_arg(*, arg):
    print(arg)
```

特殊参数组合

```python
def combined_example(pos_only, /, standard, *, kwd_only):
    print(pos_only, standard, kwd_only)

"""
运行示例
"""
>>> combined_example(1, 2, 3)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: combined_example() takes 2 positional arguments but 3 were given

>>> combined_example(1, 2, kwd_only=3)
1 2 3

>>> combined_example(1, standard=2, kwd_only=3)
1 2 3

>>> combined_example(pos_only=1, standard=2, kwd_only=3)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: combined_example() got some positional-only arguments passed as keyword arguments: 'pos_only'
```

### return

**return [表达式]** 语句用于退出函数，选择性地向调用方返回一个表达式。不带参数值的 return 语句返回 None。

```python
def sum( arg1, arg2 ):
   # 返回2个参数的和."
   total = arg1 + arg2
   print ("函数内 : ", total)
   return total
 
# 调用sum函数
total = sum( 10, 20 )
print ("函数外 : ", total)
```



## Lambda

lambda 关键字用于创建小巧的匿名函数。Lambda 函数可用于任何需要函数对象的地方。在语法上，匿名函数只能是单个表达式。在语义上，它只是常规函数定义的语法糖。与嵌套函数定义一样，lambda 函数可以引用包含作用域中的变量：

- **lambda** 只是一个表达式，函数体比 **def** 简单很多。
- lambda 的主体是一个表达式，而不是一个代码块。仅仅能在 lambda 表达式中封装有限的逻辑进去。
- lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。
- 虽然 lambda 函数看起来只能写一行，却不等同于 C 或 C++ 的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。

```python
# 语法
lambda [arg1 [,arg2,.....argn]]:expression
# 实例
>>> def make_incrementor(n):
...     return lambda x: x + n
...
>>> f = make_incrementor(42)
>>> f(0)
42
>>> f(1)
43
```

## 迭代器

 迭代器的使用非常普遍并使得 Python 成为一个统一的整体。 在幕后，for 语句会在容器对象上调用 `iter()`。 该函数返回一个定义了 `__next__()` 方法的迭代器对象，此方法将逐一访问容器中的元素。 当元素用尽时，`__next__()` 将引发 `StopIteration` 异常来通知终止 `for` 循环。 可以使用 `next()` 内置函数来调用 __next__() 方法；

- **iter()**：创建迭代器。
- **next()**：输出迭代器的下一个元素。

```python
s = 'abc'
it = iter(s)

print(it)         # <str_iterator object at 0x10c90e650>
next(it)          # 'a'
next(it)          # 'b'
next(it)          # 'c'
next(it)

# 抛出异常
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
    next(it)
StopIteration
```

```python
# 为类添加迭代器
class Reverse:
    """Iterator for looping over a sequence backwards."""
    def __init__(self, data):
        self.data = data
        self.index = len(data)

    def __iter__(self):
        return self

    def __next__(self):
        if self.index == 0:
            raise StopIteration
        self.index = self.index - 1
        return self.data[self.index]
```

## yield 生成器

Python 中还有另外一种定义生成器的方式，就是通过`yield`关键字将一个普通函数改造成生成器函数。它们的写法类似于标准的函数，但当它们要返回数据时会使用 `yield` 语句。

```python
def fibonacci(n): # 生成器函数 - 斐波那契
    a, b, counter = 0, 1, 0
    while True:
        if (counter > n): 
            return
        yield a
        a, b = b, a + b
        counter += 1

for i in fibonacci(10):
    print(i,end=" ")
```

## 推导生成式

Python 推导式是一种独特的数据处理方式，可以从一个数据序列构建另一个新的数据序列的结构体。

### 列表

```python
# 语法
[out_exp_res for out_exp in input_list]
[out_exp_res for out_exp in input_list if condition]

# 实例
multiples = [i for i in range(30) if i % 3 == 0]
print(multiples)        # [0, 3, 6, 9, 12, 15, 18, 21, 24, 27]
```

### 字典

```python
# 语法
{ key_expr: value_expr for value in collection }
{ key_expr: value_expr for value in collection if condition }

# 实例
dic = {x: x**2 for x in (2, 4, 6)}
print(dic)    # {2: 4, 4: 16, 6: 36}
```

### 集合

```python
# 语法
{ expression for item in Sequence }
{ expression for item in Sequence if conditional }

# 实例
a = {x for x in 'abracadabra' if x not in 'abc'}
print(a)      # {'d', 'r'}
```

### 元组

```python
# 语法
(expression for item in Sequence )
(expression for item in Sequence if conditional )

# 实例
a = (x for x in range(1,10))
print(a)      # 返回的是生成器对象
tuple(a)      # 使用 tuple() 函数，可以直接将生成器对象转换成元组
```

### 其他

```python
f = [x for x in range(1, 10)]
print(f)

f = [x + y for x in 'ABCDE' for y in '1234567']
print(f)
# 用列表的生成表达式语法创建列表容器
# 用这种语法创建列表之后元素已经准备就绪所以需要耗费较多的内存空间

f = [x ** 2 for x in range(1, 1000)]
print(sys.getsizeof(f))  # 查看对象占用内存的字节数
print(f)

# 请注意下面的代码创建的不是一个列表而是一个生成器对象
# 通过生成器可以获取到数据但它不占用额外的空间存储数据
# 每次需要数据的时候就通过内部的运算得到数据(需要花费额外的时间)
f = (x ** 2 for x in range(1, 1000))
print(sys.getsizeof(f))  # 相比生成式生成器不占用存储数据的空间
print(f)
for val in f:
    print(val)
```

## 全局、局部变量

**定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。**

局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。如下实例：

```python
total = 0 # 全局变量

def sum( arg1, arg2 ):
    # 返回 2 个参数的和
    total = arg1 + arg2     # total在这里是局部变量.
    print ("函数内是局部变量 : ", total)
    return total
 
#调用 sum 函数
sum( 10, 20 )
print ("函数外是全局变量 : ", total)
```

## global、nonlocal 关键字

内部作用域修改外部作用域的变量时，需要使用 global 关键字声明。反之要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字。

```python
num = 1

def fun1():
    global num        # 需要使用 global 关键字声明
    print(num) 
    num = 123
    print(num)
    
fun1()
print(num)
```

```python
def outer():
    num = 10
    def inner():
        nonlocal num   # nonlocal关键字声明
        num = 100
        print(num)
    inner()
    print(num)
    
outer()
```
